{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"VibeCheck Documentation","text":"<p>Welcome to VibeCheck - a restaurant recommendation system based on visual aesthetics and vibes!</p>"},{"location":"#what-is-vibecheck","title":"What is VibeCheck?","text":"<p>VibeCheck helps you discover restaurants that match your aesthetic preferences by analyzing the visual atmosphere and environment of dining establishments in the Washington DC area.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83c\udfa8 Visual-First Recommendations - Find restaurants based on interior/exterior aesthetics</li> <li>\ud83d\uddfa\ufe0f Interactive Map - Explore restaurants visually on an interactive map</li> <li>\ud83d\udd0d Similarity Search - Discover restaurants with similar vibes</li> <li>\ud83d\uddbc\ufe0f Image-Based Analysis - Powered by machine learning on restaurant imagery</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started</li> <li>Installation Guide</li> <li>API Reference</li> <li>Contributing Guidelines</li> </ul>"},{"location":"#project-overview","title":"Project Overview","text":"<p>VibeCheck collects images of restaurants from multiple sources, processes them using computer vision techniques, and creates embeddings that capture the aesthetic characteristics of each venue. Users can then search for restaurants that match their preferred atmosphere.</p>"},{"location":"#technology-stack","title":"Technology Stack","text":"<ul> <li>Python 3.10+</li> <li>Computer Vision: Image processing and feature extraction</li> <li>Machine Learning: Similarity matching algorithms</li> <li>Web Framework: Interactive visualization and UI</li> <li>Data Collection: SerpAPI for image gathering</li> </ul>"},{"location":"#getting-help","title":"Getting Help","text":"<ul> <li>Check our User Guide for detailed documentation</li> <li>Browse the API Reference for code documentation</li> <li>Report issues on GitHub</li> </ul>"},{"location":"about/","title":"About VibeCheck","text":""},{"location":"about/#project-background","title":"Project Background","text":"<p>VibeCheck was created as part of a Machine Learning Applications course project at Georgetown University. The goal is to help people discover restaurants based on their visual aesthetics rather than just food reviews.</p>"},{"location":"about/#team","title":"Team","text":"<ul> <li>Manav Arora</li> <li>Jessica Joy</li> <li>Ping Hill</li> <li>Kristin Lloyd</li> <li>Viviana Luccioli</li> </ul>"},{"location":"about/#motivation","title":"Motivation","text":"<p>Traditional restaurant recommendation systems focus primarily on food quality and service. VibeCheck takes a different approach by recognizing that the atmosphere and visual aesthetic of a restaurant are crucial factors in choosing where to dine.</p>"},{"location":"about/#technology","title":"Technology","text":"<p>VibeCheck leverages:</p> <ul> <li>Computer Vision for image analysis</li> <li>Machine Learning for similarity matching</li> <li>Web Scraping for data collection</li> <li>Modern Python tools and best practices</li> </ul>"},{"location":"about/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"about/#acknowledgments","title":"Acknowledgments","text":"<ul> <li>Georgetown University DSAN 6700 Course</li> <li>SerpAPI for image data</li> <li>Open source community</li> </ul>"},{"location":"about/#contact","title":"Contact","text":"<ul> <li>GitHub: kristinmlloyd/VibeCheck</li> <li>Issues: GitHub Issues</li> </ul>"},{"location":"contributing/","title":"Contributing to VibeCheck","text":"<p>Thank you for contributing to VibeCheck! This document outlines our development workflow and guidelines.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Git Workflow</li> <li>Branching Strategy</li> <li>Commit Messages</li> <li>Pull Request Process</li> <li>Code Style</li> <li>Testing</li> </ul>"},{"location":"contributing/#git-workflow","title":"Git Workflow","text":"<p>We follow a feature branch workflow with the following principles:</p> <ol> <li>Never commit directly to <code>main</code></li> <li>All changes go through Pull Requests</li> <li>All PRs require at least one review</li> <li>All tests must pass before merging</li> </ol>"},{"location":"contributing/#branching-strategy","title":"Branching Strategy","text":"<p>We use a simplified Git Flow:</p>"},{"location":"contributing/#main-branches","title":"Main Branches","text":"<ul> <li><code>main</code>: Production-ready code. Protected branch.</li> <li><code>develop</code>: Integration branch for features. Protected branch.</li> </ul>"},{"location":"contributing/#supporting-branches","title":"Supporting Branches","text":""},{"location":"contributing/#feature-branches","title":"Feature Branches","text":"<ul> <li>Naming: <code>feature/&lt;issue-number&gt;-&lt;short-description&gt;</code></li> <li>Example: <code>feature/15-microservices-architecture</code></li> <li>Branch from: <code>develop</code></li> <li>Merge into: <code>develop</code> <pre><code># Create feature branch\ngit checkout develop\ngit pull origin develop\ngit checkout -b feature/15-microservices-architecture\n\n# Work on feature, commit changes\ngit add .\ngit commit -m \"feat: add Docker configuration for API service\"\n\n# Push and create PR\ngit push origin feature/15-microservices-architecture\n</code></pre></li> </ul>"},{"location":"contributing/#bug-fix-branches","title":"Bug Fix Branches","text":"<ul> <li>Naming: <code>bugfix/&lt;issue-number&gt;-&lt;short-description&gt;</code></li> <li>Example: <code>bugfix/42-fix-image-download</code></li> <li>Branch from: <code>develop</code></li> <li>Merge into: <code>develop</code></li> </ul>"},{"location":"contributing/#hotfix-branches-for-production-bugs","title":"Hotfix Branches (for production bugs)","text":"<ul> <li>Naming: <code>hotfix/&lt;issue-number&gt;-&lt;short-description&gt;</code></li> <li>Example: <code>hotfix/99-critical-api-error</code></li> <li>Branch from: <code>main</code></li> <li>Merge into: <code>main</code> AND <code>develop</code></li> </ul>"},{"location":"contributing/#documentation-branches","title":"Documentation Branches","text":"<ul> <li>Naming: <code>docs/&lt;issue-number&gt;-&lt;short-description&gt;</code></li> <li>Example: <code>docs/10-setup-mkdocs</code></li> <li>Branch from: <code>develop</code></li> <li>Merge into: <code>develop</code></li> </ul>"},{"location":"contributing/#branch-lifecycle","title":"Branch Lifecycle","text":"<pre><code>main\n  \u2502\n  \u2514\u2500\u2500 develop\n        \u251c\u2500\u2500 feature/15-microservices-architecture\n        \u251c\u2500\u2500 feature/16-experiment-tracking\n        \u251c\u2500\u2500 bugfix/42-fix-image-download\n        \u2514\u2500\u2500 docs/10-setup-mkdocs\n</code></pre>"},{"location":"contributing/#commit-messages","title":"Commit Messages","text":"<p>We follow Conventional Commits specification:</p>"},{"location":"contributing/#format","title":"Format","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre>"},{"location":"contributing/#types","title":"Types","text":"<ul> <li><code>feat</code>: New feature</li> <li><code>fix</code>: Bug fix</li> <li><code>docs</code>: Documentation changes</li> <li><code>style</code>: Code style changes (formatting, no logic change)</li> <li><code>refactor</code>: Code refactoring</li> <li><code>test</code>: Adding or updating tests</li> <li><code>chore</code>: Maintenance tasks, dependency updates</li> </ul>"},{"location":"contributing/#examples","title":"Examples","text":"<pre><code>feat(api): add endpoint for restaurant similarity search\n\nfix(image-collector): handle duplicate images across search terms\n\ndocs(readme): add architecture diagram and setup instructions\n\ntest(preprocessor): add unit tests for image deduplication\n\nchore(deps): update dependencies to latest versions\n</code></pre>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#1-create-an-issue-first","title":"1. Create an Issue First","text":"<p>Before starting work, create an issue or claim an existing one.</p>"},{"location":"contributing/#2-create-your-branch","title":"2. Create Your Branch","text":"<pre><code>git checkout develop\ngit pull origin develop\ngit checkout -b feature/&lt;issue-number&gt;-&lt;description&gt;\n</code></pre>"},{"location":"contributing/#3-make-your-changes","title":"3. Make Your Changes","text":"<ul> <li>Write clear, concise code</li> <li>Follow our code style guidelines</li> <li>Add tests for new functionality</li> <li>Update documentation as needed</li> </ul>"},{"location":"contributing/#4-commit-your-changes","title":"4. Commit Your Changes","text":"<pre><code>git add .\ngit commit -m \"feat: your descriptive commit message\"\n</code></pre>"},{"location":"contributing/#5-push-and-create-pr","title":"5. Push and Create PR","text":"<pre><code>git push origin feature/&lt;issue-number&gt;-&lt;description&gt;\n</code></pre> <p>Then create a Pull Request on GitHub: - Fill out the PR template completely - Link the related issue using \"Closes #XX\" - Request reviews from team members - Ensure CI checks pass</p>"},{"location":"contributing/#6-code-review","title":"6. Code Review","text":"<ul> <li>Address all review comments</li> <li>Make requested changes</li> <li>Push updates to the same branch</li> </ul>"},{"location":"contributing/#7-merge","title":"7. Merge","text":"<p>Once approved and all checks pass: - Squash and merge (preferred for feature branches) - Regular merge (for multi-commit features that tell a story) - Never force push to shared branches</p>"},{"location":"contributing/#8-clean-up","title":"8. Clean Up","text":"<pre><code># After merge, delete your local branch\ngit checkout develop\ngit pull origin develop\ngit branch -d feature/&lt;issue-number&gt;-&lt;description&gt;\n</code></pre>"},{"location":"contributing/#code-style","title":"Code Style","text":""},{"location":"contributing/#python","title":"Python","text":"<ul> <li>Follow PEP 8</li> <li>Use <code>ruff</code> for linting and formatting</li> <li>Maximum line length: 88 characters (Black default)</li> <li>Use type hints where appropriate <pre><code>def process_image(image_path: str, size: tuple[int, int]) -&gt; Image:\n    \"\"\"\n    Process an image by resizing it.\n\n    Args:\n        image_path: Path to the image file\n        size: Target size as (width, height)\n\n    Returns:\n        Processed PIL Image object\n    \"\"\"\n    pass\n</code></pre></li> </ul>"},{"location":"contributing/#code-style-guidelines","title":"Code Style Guidelines","text":""},{"location":"contributing/#python-style","title":"Python Style","text":"<p>We follow PEP 8 with these specifics: - Line length: 88 characters (Black default) - Quote style: Double quotes - Indentation: 4 spaces - Type hints: Use where appropriate - Docstrings: Google-style format</p>"},{"location":"contributing/#linting-and-formatting","title":"Linting and Formatting","text":"<p>We use Ruff for both linting and formatting. Configuration is in <code>.ruff.toml</code>.</p> <p>Manual commands: <pre><code># Check linting issues\npoetry run ruff check src/ tests/\n\n# Auto-fix linting issues\npoetry run ruff check src/ tests/ --fix\n\n# Check formatting\npoetry run ruff format --check src/ tests/\n\n# Auto-format code\npoetry run ruff format src/ tests/\n</code></pre></p>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>Pre-commit hooks automatically check and format code before each commit.</p> <p>Setup (one-time): <pre><code>poetry run pre-commit install\n</code></pre></p> <p>What the hooks do: - Run ruff linting with auto-fix - Run ruff formatting - Remove trailing whitespace - Ensure newline at end of files - Validate YAML syntax - Prevent large file commits (&gt;1MB)</p> <p>If hooks fail: The commit will be blocked. Review the changes the hooks made, stage them, and commit again.</p> <p>Bypass hooks (not recommended): <pre><code>git commit --no-verify\n</code></pre></p>"},{"location":"contributing/#ci-enforcement","title":"CI Enforcement","text":"<ul> <li>All PRs must pass <code>ruff check</code> and <code>ruff format --check</code></li> <li>CI runs automatically on every push and PR</li> <li>Status checks must pass before merging</li> </ul>"},{"location":"contributing/#docstrings","title":"Docstrings","text":"<p>Use Google-style docstrings: <pre><code>def calculate_similarity(img1: np.ndarray, img2: np.ndarray) -&gt; float:\n    \"\"\"\n    Calculate similarity between two images.\n\n    Args:\n        img1: First image as numpy array\n        img2: Second image as numpy array\n\n    Returns:\n        Similarity score between 0 and 1\n\n    Raises:\n        ValueError: If images have different dimensions\n    \"\"\"\n    pass\n</code></pre></p>"},{"location":"contributing/#testing","title":"Testing","text":""},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Place tests in <code>tests/</code> directory mirroring <code>src/</code> structure</li> <li>Use descriptive test names: <code>test_&lt;functionality&gt;_&lt;scenario&gt;_&lt;expected_result&gt;</code></li> <li>Aim for &gt;80% code coverage <pre><code>def test_image_collector_removes_duplicates_by_hash():\n    \"\"\"Test that duplicate images are detected and removed.\"\"\"\n    # Test implementation\n    pass\n</code></pre></li> </ul>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npytest\n\n# Run with coverage\npytest --cov=src --cov-report=html\n\n# Run specific test file\npytest tests/test_image_collector.py\n\n# Run tests matching pattern\npytest -k \"test_duplicate\"\n</code></pre>"},{"location":"contributing/#issue-tracking","title":"Issue Tracking","text":"<ul> <li>Always create an issue before starting work</li> <li>Use appropriate labels (bug, enhancement, documentation, etc.)</li> <li>Assign the issue to yourself when you start working on it</li> <li>Reference issues in commits and PRs using <code>#issue-number</code></li> <li>Close issues via PR descriptions: \"Closes #15\"</li> </ul>"},{"location":"contributing/#questions","title":"Questions?","text":"<p>If you have questions about contributing: 1. Check existing documentation 2. Search closed issues 3. Open a discussion on GitHub Discussions 4. Ask in team chat</p>"},{"location":"contributing/#thank-you","title":"Thank You!","text":"<p>Your contributions make VibeCheck better for everyone!</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>vibecheck<ul> <li>analysis<ul> <li>vibe_mapper</li> </ul> </li> <li>api</li> <li>client</li> <li>database</li> <li>embeddings<ul> <li>generator</li> <li>models</li> </ul> </li> <li>logging_config</li> <li>mlflow_config</li> <li>monitoring<ul> <li>evidently_monitor</li> </ul> </li> <li>recommender</li> <li>utils</li> </ul> </li> </ul>"},{"location":"reference/vibecheck/","title":"vibecheck","text":""},{"location":"reference/vibecheck/#vibecheck","title":"<code>vibecheck</code>","text":"<p>VibeCheck - Restaurant recommendation based on visual aesthetics.</p>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender","title":"<code>VibeCheckRecommender</code>","text":"<p>Main recommendation engine - same as before but with updated paths.</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>class VibeCheckRecommender:\n    \"\"\"Main recommendation engine - same as before but with updated paths.\"\"\"\n\n    def __init__(\n        self,\n        db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n        image_dir: Path = Path(\"data/images/sample_images\"),\n        faiss_index_path: Path = Path(\"data/embeddings/vibecheck_index.faiss\"),\n        meta_ids_path: Path = Path(\"data/restaurants_info/meta_ids.npy\"),\n    ):\n        \"\"\"Initialize with new data paths.\"\"\"\n        logger.info(\"Initializing VibeCheckRecommender\")\n        logger.debug(f\"Database path: {db_path}\")\n        logger.debug(f\"Image directory: {image_dir}\")\n        logger.debug(f\"FAISS index: {faiss_index_path}\")\n        logger.debug(f\"Meta IDs: {meta_ids_path}\")\n\n        self.db = RestaurantDatabase(db_path)\n        self.db_path = db_path  # Store for get_restaurant_info\n        self.image_dir = Path(image_dir)\n\n        # Load models\n        logger.info(\"Loading models...\")\n        self.text_model = ModelCache.get_text_model()\n        self.clip_model, self.clip_preprocess = ModelCache.get_clip_model()\n        self.device = ModelCache.get_device()\n\n        # Load search index\n        logger.info(\"Loading FAISS index...\")\n        try:\n            self.index = faiss.read_index(str(faiss_index_path))\n            self.meta_ids = np.load(str(meta_ids_path))\n            logger.info(f\"Loaded index with {len(self.meta_ids)} entries\")\n        except Exception as e:\n            logger.error(f\"Failed to load index: {e}\")\n            raise\n\n    def encode_text(self, text: str) -&gt; np.ndarray:\n        \"\"\"\n        Encode text query into embedding vector.\n\n        Args:\n            text: Text description of desired vibe.\n\n        Returns:\n            Normalized embedding vector of shape (384,).\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; vector = recommender.encode_text(\"cozy cafe\")\n            &gt;&gt;&gt; vector.shape\n            (384,)\n        \"\"\"\n        logger.debug(\n            f\"Encoding text: {text[:50]}...\"\n            if len(text) &gt; 50\n            else f\"Encoding text: {text}\"\n        )\n        return self.text_model.encode(\n            text, convert_to_numpy=True, normalize_embeddings=True\n        )\n\n    def encode_image(self, image: Image.Image) -&gt; np.ndarray:\n        \"\"\"\n        Encode image into CLIP embedding vector.\n\n        Args:\n            image: PIL Image of desired aesthetic.\n\n        Returns:\n            Normalized embedding vector of shape (512,).\n\n        Example:\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; img = Image.open(\"restaurant.jpg\")\n            &gt;&gt;&gt; vector = recommender.encode_image(img)\n            &gt;&gt;&gt; vector.shape\n            (512,)\n        \"\"\"\n        logger.debug(\"Encoding image...\")\n        img_tensor = self.clip_preprocess(image).unsqueeze(0).to(self.device)\n\n        with torch.no_grad():\n            img_vec = self.clip_model.encode_image(img_tensor)\n\n        img_vec /= img_vec.norm(dim=-1, keepdim=True)\n        return img_vec.cpu().numpy()[0]\n\n    def encode_query(\n        self, text: str | None = None, image: Image.Image | None = None\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Encode a multimodal query (text and/or image) into a combined embedding.\n\n        Args:\n            text: Optional text description of desired vibe.\n            image: Optional PIL Image of desired aesthetic.\n\n        Returns:\n            Combined embedding vector of shape (896,) = (384 text + 512 image).\n\n        Raises:\n            ValueError: If both text and image are None.\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; # Text only\n            &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\")\n            &gt;&gt;&gt; # Image only\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n            &gt;&gt;&gt; vec = recommender.encode_query(image=img)\n            &gt;&gt;&gt; # Both\n            &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\", image=img)\n        \"\"\"\n        if text is None and image is None:\n            logger.error(\"encode_query called with no text or image\")\n            raise ValueError(\"Must provide either text or image query\")\n\n        logger.info(f\"Encoding query - text: {bool(text)}, image: {bool(image)}\")\n\n        # Encode text (or use zeros if not provided)\n        text_vec = self.encode_text(text) if text else np.zeros((384,))\n\n        # Encode image (or use zeros if not provided)\n        image_vec = self.encode_image(image) if image else np.zeros((512,))\n\n        # Concatenate into single vector\n        combined = np.concatenate([text_vec, image_vec]).astype(\"float32\")\n        return combined[None, :]  # Add batch dimension\n\n    def search(\n        self, query_vector: np.ndarray, top_k: int = 5\n    ) -&gt; list[tuple[str, float]]:\n        \"\"\"\n        Search the FAISS index for similar restaurants.\n\n        Args:\n            query_vector: Query embedding vector of shape (1, 896).\n            top_k: Number of top results to return.\n\n        Returns:\n            List of (restaurant_id, distance) tuples.\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; query_vec = recommender.encode_query(text=\"cozy cafe\")\n            &gt;&gt;&gt; results = recommender.search(query_vec, top_k=5)\n            &gt;&gt;&gt; for rid, distance in results:\n            ...     print(f\"Restaurant {rid}: distance={distance:.4f}\")\n        \"\"\"\n        logger.debug(f\"Searching index for top {top_k} results\")\n        distances, indices = self.index.search(query_vector, top_k)\n\n        results = []\n        for idx, distance in zip(indices[0], distances[0], strict=False):\n            restaurant_id = self.meta_ids[idx]\n            results.append((restaurant_id, float(distance)))\n\n        logger.debug(f\"Found {len(results)} results\")\n        return results\n\n    def get_restaurant_info(self, restaurant_id: str) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Get detailed information about a restaurant from the database.\n\n        Args:\n            restaurant_id: Unique restaurant identifier.\n\n        Returns:\n            Dictionary with restaurant details or None if not found.\n            Keys: 'id', 'name', 'rating', 'address', 'image_url', 'image_path'\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; info = recommender.get_restaurant_info(\"some_id\")\n            &gt;&gt;&gt; print(info['name'])\n            &gt;&gt;&gt; print(info['rating'])\n        \"\"\"\n        logger.debug(f\"Fetching restaurant info: {restaurant_id}\")\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                row = conn.execute(\n                    \"SELECT name, rating, address, image_url FROM restaurants WHERE id=?\",\n                    (restaurant_id,),\n                ).fetchone()\n\n            if not row:\n                logger.debug(f\"Restaurant not found: {restaurant_id}\")\n                return None\n\n            name, rating, address, image_url = row\n            image_path = self.image_dir / f\"{restaurant_id}.jpg\"\n\n            logger.debug(f\"Found restaurant: {name}\")\n            return {\n                \"id\": restaurant_id,\n                \"name\": name,\n                \"rating\": rating,\n                \"address\": address,\n                \"image_url\": image_url,\n                \"image_path\": str(image_path) if image_path.exists() else None,\n            }\n\n        except Exception as e:\n            logger.error(f\"Error fetching restaurant {restaurant_id}: {e}\")\n            return None\n\n    def search_by_text(self, text: str, top_k: int = 5) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Search for restaurants matching a text description.\n\n        Args:\n            text: Description of desired vibe (e.g., \"cozy cafe with plants\").\n            top_k: Number of results to return.\n\n        Returns:\n            List of restaurant dictionaries with full information.\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; results = recommender.search_by_text(\"cozy cafe with plants\", top_k=3)\n            &gt;&gt;&gt; for resto in results:\n            ...     print(f\"{resto['name']}: {resto['rating']} stars\")\n        \"\"\"\n        logger.info(\n            f\"Text search: '{text[:50]}...' (top_k={top_k})\"\n            if len(text) &gt; 50\n            else f\"Text search: '{text}' (top_k={top_k})\"\n        )\n\n        query_vec = self.encode_query(text=text)\n        search_results = self.search(query_vec, top_k=top_k)\n\n        restaurants = []\n        for restaurant_id, distance in search_results:\n            info = self.get_restaurant_info(restaurant_id)\n            if info:\n                info[\"distance\"] = distance\n                info[\"similarity\"] = 1.0 / (\n                    1.0 + distance\n                )  # Convert distance to similarity\n                restaurants.append(info)\n\n        logger.info(f\"Returning {len(restaurants)} results\")\n        return restaurants\n\n    def search_by_image(\n        self, image: Image.Image, top_k: int = 5\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Search for restaurants matching an image aesthetic.\n\n        Args:\n            image: PIL Image of desired aesthetic.\n            top_k: Number of results to return.\n\n        Returns:\n            List of restaurant dictionaries with full information.\n\n        Example:\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; img = Image.open(\"ideal_restaurant.jpg\")\n            &gt;&gt;&gt; results = recommender.search_by_image(img, top_k=3)\n            &gt;&gt;&gt; for resto in results:\n            ...     print(resto['name'])\n        \"\"\"\n        logger.info(f\"Image search (top_k={top_k})\")\n\n        query_vec = self.encode_query(image=image)\n        search_results = self.search(query_vec, top_k=top_k)\n\n        restaurants = []\n        for restaurant_id, distance in search_results:\n            info = self.get_restaurant_info(restaurant_id)\n            if info:\n                info[\"distance\"] = distance\n                info[\"similarity\"] = 1.0 / (1.0 + distance)\n                restaurants.append(info)\n\n        logger.info(f\"Returning {len(restaurants)} results\")\n        return restaurants\n\n    def search_multimodal(\n        self, text: str | None = None, image: Image.Image | None = None, top_k: int = 5\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Search using both text and image simultaneously.\n\n        Args:\n            text: Optional text description.\n            image: Optional PIL Image.\n            top_k: Number of results to return.\n\n        Returns:\n            List of restaurant dictionaries with full information.\n\n        Example:\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n            &gt;&gt;&gt; results = recommender.search_multimodal(\n            ...     text=\"cozy atmosphere\",\n            ...     image=img,\n            ...     top_k=5\n            ... )\n        \"\"\"\n        logger.info(\n            f\"Multimodal search (text={bool(text)}, image={bool(image)}, top_k={top_k})\"\n        )\n\n        query_vec = self.encode_query(text=text, image=image)\n        search_results = self.search(query_vec, top_k=top_k)\n\n        restaurants = []\n        for restaurant_id, distance in search_results:\n            info = self.get_restaurant_info(restaurant_id)\n            if info:\n                info[\"distance\"] = distance\n                info[\"similarity\"] = 1.0 / (1.0 + distance)\n                restaurants.append(info)\n\n        logger.info(f\"Returning {len(restaurants)} results\")\n        return restaurants\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.__init__","title":"<code>__init__(db_path=Path('data/restaurants_info/restaurants.db'), image_dir=Path('data/images/sample_images'), faiss_index_path=Path('data/embeddings/vibecheck_index.faiss'), meta_ids_path=Path('data/restaurants_info/meta_ids.npy'))</code>","text":"<p>Initialize with new data paths.</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def __init__(\n    self,\n    db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n    image_dir: Path = Path(\"data/images/sample_images\"),\n    faiss_index_path: Path = Path(\"data/embeddings/vibecheck_index.faiss\"),\n    meta_ids_path: Path = Path(\"data/restaurants_info/meta_ids.npy\"),\n):\n    \"\"\"Initialize with new data paths.\"\"\"\n    logger.info(\"Initializing VibeCheckRecommender\")\n    logger.debug(f\"Database path: {db_path}\")\n    logger.debug(f\"Image directory: {image_dir}\")\n    logger.debug(f\"FAISS index: {faiss_index_path}\")\n    logger.debug(f\"Meta IDs: {meta_ids_path}\")\n\n    self.db = RestaurantDatabase(db_path)\n    self.db_path = db_path  # Store for get_restaurant_info\n    self.image_dir = Path(image_dir)\n\n    # Load models\n    logger.info(\"Loading models...\")\n    self.text_model = ModelCache.get_text_model()\n    self.clip_model, self.clip_preprocess = ModelCache.get_clip_model()\n    self.device = ModelCache.get_device()\n\n    # Load search index\n    logger.info(\"Loading FAISS index...\")\n    try:\n        self.index = faiss.read_index(str(faiss_index_path))\n        self.meta_ids = np.load(str(meta_ids_path))\n        logger.info(f\"Loaded index with {len(self.meta_ids)} entries\")\n    except Exception as e:\n        logger.error(f\"Failed to load index: {e}\")\n        raise\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.encode_image","title":"<code>encode_image(image)</code>","text":"<p>Encode image into CLIP embedding vector.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>PIL Image of desired aesthetic.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized embedding vector of shape (512,).</p> Example <p>from PIL import Image recommender = VibeCheckRecommender() img = Image.open(\"restaurant.jpg\") vector = recommender.encode_image(img) vector.shape (512,)</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def encode_image(self, image: Image.Image) -&gt; np.ndarray:\n    \"\"\"\n    Encode image into CLIP embedding vector.\n\n    Args:\n        image: PIL Image of desired aesthetic.\n\n    Returns:\n        Normalized embedding vector of shape (512,).\n\n    Example:\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; img = Image.open(\"restaurant.jpg\")\n        &gt;&gt;&gt; vector = recommender.encode_image(img)\n        &gt;&gt;&gt; vector.shape\n        (512,)\n    \"\"\"\n    logger.debug(\"Encoding image...\")\n    img_tensor = self.clip_preprocess(image).unsqueeze(0).to(self.device)\n\n    with torch.no_grad():\n        img_vec = self.clip_model.encode_image(img_tensor)\n\n    img_vec /= img_vec.norm(dim=-1, keepdim=True)\n    return img_vec.cpu().numpy()[0]\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.encode_query","title":"<code>encode_query(text=None, image=None)</code>","text":"<p>Encode a multimodal query (text and/or image) into a combined embedding.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Optional text description of desired vibe.</p> <code>None</code> <code>image</code> <code>Image | None</code> <p>Optional PIL Image of desired aesthetic.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Combined embedding vector of shape (896,) = (384 text + 512 image).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both text and image are None.</p> Example <p>recommender = VibeCheckRecommender()</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def encode_query(\n    self, text: str | None = None, image: Image.Image | None = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Encode a multimodal query (text and/or image) into a combined embedding.\n\n    Args:\n        text: Optional text description of desired vibe.\n        image: Optional PIL Image of desired aesthetic.\n\n    Returns:\n        Combined embedding vector of shape (896,) = (384 text + 512 image).\n\n    Raises:\n        ValueError: If both text and image are None.\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; # Text only\n        &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\")\n        &gt;&gt;&gt; # Image only\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n        &gt;&gt;&gt; vec = recommender.encode_query(image=img)\n        &gt;&gt;&gt; # Both\n        &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\", image=img)\n    \"\"\"\n    if text is None and image is None:\n        logger.error(\"encode_query called with no text or image\")\n        raise ValueError(\"Must provide either text or image query\")\n\n    logger.info(f\"Encoding query - text: {bool(text)}, image: {bool(image)}\")\n\n    # Encode text (or use zeros if not provided)\n    text_vec = self.encode_text(text) if text else np.zeros((384,))\n\n    # Encode image (or use zeros if not provided)\n    image_vec = self.encode_image(image) if image else np.zeros((512,))\n\n    # Concatenate into single vector\n    combined = np.concatenate([text_vec, image_vec]).astype(\"float32\")\n    return combined[None, :]  # Add batch dimension\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.encode_query--text-only","title":"Text only","text":"<p>vec = recommender.encode_query(text=\"cozy cafe\")</p>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.encode_query--image-only","title":"Image only","text":"<p>from PIL import Image img = Image.open(\"cafe.jpg\") vec = recommender.encode_query(image=img)</p>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.encode_query--both","title":"Both","text":"<p>vec = recommender.encode_query(text=\"cozy cafe\", image=img)</p>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.encode_text","title":"<code>encode_text(text)</code>","text":"<p>Encode text query into embedding vector.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text description of desired vibe.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized embedding vector of shape (384,).</p> Example <p>recommender = VibeCheckRecommender() vector = recommender.encode_text(\"cozy cafe\") vector.shape (384,)</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def encode_text(self, text: str) -&gt; np.ndarray:\n    \"\"\"\n    Encode text query into embedding vector.\n\n    Args:\n        text: Text description of desired vibe.\n\n    Returns:\n        Normalized embedding vector of shape (384,).\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; vector = recommender.encode_text(\"cozy cafe\")\n        &gt;&gt;&gt; vector.shape\n        (384,)\n    \"\"\"\n    logger.debug(\n        f\"Encoding text: {text[:50]}...\"\n        if len(text) &gt; 50\n        else f\"Encoding text: {text}\"\n    )\n    return self.text_model.encode(\n        text, convert_to_numpy=True, normalize_embeddings=True\n    )\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.get_restaurant_info","title":"<code>get_restaurant_info(restaurant_id)</code>","text":"<p>Get detailed information about a restaurant from the database.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_id</code> <code>str</code> <p>Unique restaurant identifier.</p> required <p>Returns:</p> Name Type Description <code>dict[str, Any] | None</code> <p>Dictionary with restaurant details or None if not found.</p> <code>Keys</code> <code>dict[str, Any] | None</code> <p>'id', 'name', 'rating', 'address', 'image_url', 'image_path'</p> Example <p>recommender = VibeCheckRecommender() info = recommender.get_restaurant_info(\"some_id\") print(info['name']) print(info['rating'])</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def get_restaurant_info(self, restaurant_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get detailed information about a restaurant from the database.\n\n    Args:\n        restaurant_id: Unique restaurant identifier.\n\n    Returns:\n        Dictionary with restaurant details or None if not found.\n        Keys: 'id', 'name', 'rating', 'address', 'image_url', 'image_path'\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; info = recommender.get_restaurant_info(\"some_id\")\n        &gt;&gt;&gt; print(info['name'])\n        &gt;&gt;&gt; print(info['rating'])\n    \"\"\"\n    logger.debug(f\"Fetching restaurant info: {restaurant_id}\")\n    try:\n        with sqlite3.connect(self.db_path) as conn:\n            row = conn.execute(\n                \"SELECT name, rating, address, image_url FROM restaurants WHERE id=?\",\n                (restaurant_id,),\n            ).fetchone()\n\n        if not row:\n            logger.debug(f\"Restaurant not found: {restaurant_id}\")\n            return None\n\n        name, rating, address, image_url = row\n        image_path = self.image_dir / f\"{restaurant_id}.jpg\"\n\n        logger.debug(f\"Found restaurant: {name}\")\n        return {\n            \"id\": restaurant_id,\n            \"name\": name,\n            \"rating\": rating,\n            \"address\": address,\n            \"image_url\": image_url,\n            \"image_path\": str(image_path) if image_path.exists() else None,\n        }\n\n    except Exception as e:\n        logger.error(f\"Error fetching restaurant {restaurant_id}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.search","title":"<code>search(query_vector, top_k=5)</code>","text":"<p>Search the FAISS index for similar restaurants.</p> <p>Parameters:</p> Name Type Description Default <code>query_vector</code> <code>ndarray</code> <p>Query embedding vector of shape (1, 896).</p> required <code>top_k</code> <code>int</code> <p>Number of top results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[tuple[str, float]]</code> <p>List of (restaurant_id, distance) tuples.</p> Example <p>recommender = VibeCheckRecommender() query_vec = recommender.encode_query(text=\"cozy cafe\") results = recommender.search(query_vec, top_k=5) for rid, distance in results: ...     print(f\"Restaurant {rid}: distance={distance:.4f}\")</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search(\n    self, query_vector: np.ndarray, top_k: int = 5\n) -&gt; list[tuple[str, float]]:\n    \"\"\"\n    Search the FAISS index for similar restaurants.\n\n    Args:\n        query_vector: Query embedding vector of shape (1, 896).\n        top_k: Number of top results to return.\n\n    Returns:\n        List of (restaurant_id, distance) tuples.\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; query_vec = recommender.encode_query(text=\"cozy cafe\")\n        &gt;&gt;&gt; results = recommender.search(query_vec, top_k=5)\n        &gt;&gt;&gt; for rid, distance in results:\n        ...     print(f\"Restaurant {rid}: distance={distance:.4f}\")\n    \"\"\"\n    logger.debug(f\"Searching index for top {top_k} results\")\n    distances, indices = self.index.search(query_vector, top_k)\n\n    results = []\n    for idx, distance in zip(indices[0], distances[0], strict=False):\n        restaurant_id = self.meta_ids[idx]\n        results.append((restaurant_id, float(distance)))\n\n    logger.debug(f\"Found {len(results)} results\")\n    return results\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.search_by_image","title":"<code>search_by_image(image, top_k=5)</code>","text":"<p>Search for restaurants matching an image aesthetic.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>PIL Image of desired aesthetic.</p> required <code>top_k</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of restaurant dictionaries with full information.</p> Example <p>from PIL import Image recommender = VibeCheckRecommender() img = Image.open(\"ideal_restaurant.jpg\") results = recommender.search_by_image(img, top_k=3) for resto in results: ...     print(resto['name'])</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search_by_image(\n    self, image: Image.Image, top_k: int = 5\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Search for restaurants matching an image aesthetic.\n\n    Args:\n        image: PIL Image of desired aesthetic.\n        top_k: Number of results to return.\n\n    Returns:\n        List of restaurant dictionaries with full information.\n\n    Example:\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; img = Image.open(\"ideal_restaurant.jpg\")\n        &gt;&gt;&gt; results = recommender.search_by_image(img, top_k=3)\n        &gt;&gt;&gt; for resto in results:\n        ...     print(resto['name'])\n    \"\"\"\n    logger.info(f\"Image search (top_k={top_k})\")\n\n    query_vec = self.encode_query(image=image)\n    search_results = self.search(query_vec, top_k=top_k)\n\n    restaurants = []\n    for restaurant_id, distance in search_results:\n        info = self.get_restaurant_info(restaurant_id)\n        if info:\n            info[\"distance\"] = distance\n            info[\"similarity\"] = 1.0 / (1.0 + distance)\n            restaurants.append(info)\n\n    logger.info(f\"Returning {len(restaurants)} results\")\n    return restaurants\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.search_by_text","title":"<code>search_by_text(text, top_k=5)</code>","text":"<p>Search for restaurants matching a text description.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Description of desired vibe (e.g., \"cozy cafe with plants\").</p> required <code>top_k</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of restaurant dictionaries with full information.</p> Example <p>recommender = VibeCheckRecommender() results = recommender.search_by_text(\"cozy cafe with plants\", top_k=3) for resto in results: ...     print(f\"{resto['name']}: {resto['rating']} stars\")</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search_by_text(self, text: str, top_k: int = 5) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Search for restaurants matching a text description.\n\n    Args:\n        text: Description of desired vibe (e.g., \"cozy cafe with plants\").\n        top_k: Number of results to return.\n\n    Returns:\n        List of restaurant dictionaries with full information.\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; results = recommender.search_by_text(\"cozy cafe with plants\", top_k=3)\n        &gt;&gt;&gt; for resto in results:\n        ...     print(f\"{resto['name']}: {resto['rating']} stars\")\n    \"\"\"\n    logger.info(\n        f\"Text search: '{text[:50]}...' (top_k={top_k})\"\n        if len(text) &gt; 50\n        else f\"Text search: '{text}' (top_k={top_k})\"\n    )\n\n    query_vec = self.encode_query(text=text)\n    search_results = self.search(query_vec, top_k=top_k)\n\n    restaurants = []\n    for restaurant_id, distance in search_results:\n        info = self.get_restaurant_info(restaurant_id)\n        if info:\n            info[\"distance\"] = distance\n            info[\"similarity\"] = 1.0 / (\n                1.0 + distance\n            )  # Convert distance to similarity\n            restaurants.append(info)\n\n    logger.info(f\"Returning {len(restaurants)} results\")\n    return restaurants\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.VibeCheckRecommender.search_multimodal","title":"<code>search_multimodal(text=None, image=None, top_k=5)</code>","text":"<p>Search using both text and image simultaneously.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Optional text description.</p> <code>None</code> <code>image</code> <code>Image | None</code> <p>Optional PIL Image.</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of restaurant dictionaries with full information.</p> Example <p>from PIL import Image recommender = VibeCheckRecommender() img = Image.open(\"cafe.jpg\") results = recommender.search_multimodal( ...     text=\"cozy atmosphere\", ...     image=img, ...     top_k=5 ... )</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search_multimodal(\n    self, text: str | None = None, image: Image.Image | None = None, top_k: int = 5\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Search using both text and image simultaneously.\n\n    Args:\n        text: Optional text description.\n        image: Optional PIL Image.\n        top_k: Number of results to return.\n\n    Returns:\n        List of restaurant dictionaries with full information.\n\n    Example:\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n        &gt;&gt;&gt; results = recommender.search_multimodal(\n        ...     text=\"cozy atmosphere\",\n        ...     image=img,\n        ...     top_k=5\n        ... )\n    \"\"\"\n    logger.info(\n        f\"Multimodal search (text={bool(text)}, image={bool(image)}, top_k={top_k})\"\n    )\n\n    query_vec = self.encode_query(text=text, image=image)\n    search_results = self.search(query_vec, top_k=top_k)\n\n    restaurants = []\n    for restaurant_id, distance in search_results:\n        info = self.get_restaurant_info(restaurant_id)\n        if info:\n            info[\"distance\"] = distance\n            info[\"similarity\"] = 1.0 / (1.0 + distance)\n            restaurants.append(info)\n\n    logger.info(f\"Returning {len(restaurants)} results\")\n    return restaurants\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.get_logger","title":"<code>get_logger(name)</code>","text":"<p>Get a logger instance for a specific module.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the module (typically name).</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>Logger instance.</p> Example <p>from vibecheck.logging_config import get_logger logger = get_logger(name) logger.info(\"Processing started\")</p> Source code in <code>src/vibecheck/logging_config.py</code> <pre><code>def get_logger(name: str) -&gt; logging.Logger:\n    \"\"\"\n    Get a logger instance for a specific module.\n\n    Args:\n        name: Name of the module (typically __name__).\n\n    Returns:\n        Logger instance.\n\n    Example:\n        &gt;&gt;&gt; from vibecheck.logging_config import get_logger\n        &gt;&gt;&gt; logger = get_logger(__name__)\n        &gt;&gt;&gt; logger.info(\"Processing started\")\n    \"\"\"\n    return logging.getLogger(f\"vibecheck.{name}\")\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.hello_vibecheck","title":"<code>hello_vibecheck()</code>","text":"<p>Return a greeting message.</p> <p>Returns:</p> Type Description <code>str</code> <p>A welcome message string.</p> Example <p>hello_vibecheck() 'Welcome to VibeCheck!'</p> Source code in <code>src/vibecheck/utils.py</code> <pre><code>def hello_vibecheck() -&gt; str:\n    \"\"\"\n    Return a greeting message.\n\n    Returns:\n        A welcome message string.\n\n    Example:\n        &gt;&gt;&gt; hello_vibecheck()\n        'Welcome to VibeCheck!'\n    \"\"\"\n    return \"Welcome to VibeCheck!\"\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.setup_logging","title":"<code>setup_logging(level=logging.INFO, log_file=None, log_format=None)</code>","text":"<p>Configure logging for the VibeCheck application.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> <code>INFO</code> <code>log_file</code> <code>Path | None</code> <p>Optional path to log file. If None, logs only to console.</p> <code>None</code> <code>log_format</code> <code>str | None</code> <p>Optional custom log format string.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured logger instance.</p> Example <p>from vibecheck.logging_config import setup_logging logger = setup_logging(level=logging.DEBUG) logger.info(\"Application started\")</p> Source code in <code>src/vibecheck/logging_config.py</code> <pre><code>def setup_logging(\n    level: int = logging.INFO,\n    log_file: Path | None = None,\n    log_format: str | None = None,\n) -&gt; logging.Logger:\n    \"\"\"\n    Configure logging for the VibeCheck application.\n\n    Args:\n        level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).\n        log_file: Optional path to log file. If None, logs only to console.\n        log_format: Optional custom log format string.\n\n    Returns:\n        Configured logger instance.\n\n    Example:\n        &gt;&gt;&gt; from vibecheck.logging_config import setup_logging\n        &gt;&gt;&gt; logger = setup_logging(level=logging.DEBUG)\n        &gt;&gt;&gt; logger.info(\"Application started\")\n    \"\"\"\n    if log_format is None:\n        log_format = \"%(asctime)s | %(levelname)-8s | %(name)s | %(message)s\"\n\n    # Create formatter\n    formatter = logging.Formatter(log_format, datefmt=\"%Y-%m-%d %H:%M:%S\")\n\n    # Get root logger for vibecheck\n    logger = logging.getLogger(\"vibecheck\")\n    logger.setLevel(level)\n\n    # Remove existing handlers to avoid duplicates\n    logger.handlers.clear()\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(level)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n\n    # File handler (optional)\n    if log_file:\n        log_file = Path(log_file)\n        log_file.parent.mkdir(parents=True, exist_ok=True)\n\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setLevel(level)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n        logger.info(f\"Logging to file: {log_file}\")\n\n    return logger\n</code></pre>"},{"location":"reference/vibecheck/#vibecheck.validate_restaurant_name","title":"<code>validate_restaurant_name(name)</code>","text":"<p>Validate a restaurant name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The restaurant name to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the name is valid, False otherwise.</p> Example <p>validate_restaurant_name(\"Joe's Pizza\") True validate_restaurant_name(\"\") False</p> Source code in <code>src/vibecheck/utils.py</code> <pre><code>def validate_restaurant_name(name: str) -&gt; bool:\n    \"\"\"\n    Validate a restaurant name.\n\n    Args:\n        name: The restaurant name to validate.\n\n    Returns:\n        True if the name is valid, False otherwise.\n\n    Example:\n        &gt;&gt;&gt; validate_restaurant_name(\"Joe's Pizza\")\n        True\n        &gt;&gt;&gt; validate_restaurant_name(\"\")\n        False\n    \"\"\"\n    return bool(name and name.strip())\n</code></pre>"},{"location":"reference/vibecheck/client/","title":"client","text":""},{"location":"reference/vibecheck/client/#vibecheck.client","title":"<code>vibecheck.client</code>","text":"<p>Main VibeCheck client for restaurant recommendations based on visual aesthetics.</p>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient","title":"<code>VibeCheckClient</code>","text":"<p>Client for interacting with VibeCheck restaurant recommendation system.</p> <p>The VibeCheck client provides a simple interface for: - Collecting restaurant images - Processing and analyzing visual aesthetics - Finding similar restaurants based on vibes - Generating recommendations</p> <p>Parameters:</p> Name Type Description Default <code>api_key</code> <code>str | None</code> <p>Optional API key for data collection services (e.g., SerpAPI).</p> <code>None</code> <code>model_path</code> <code>Path | None</code> <p>Path to pre-trained model for embeddings.</p> <code>None</code> <code>data_dir</code> <code>Path</code> <p>Directory for storing restaurant data and images.</p> <code>Path('./data')</code> Example <p>from vibecheck import VibeCheckClient client = VibeCheckClient(api_key=\"your_key\") recommendations = client.get_similar_restaurants(\"Founding Farmers\") print(recommendations)</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>class VibeCheckClient:\n    \"\"\"\n    Client for interacting with VibeCheck restaurant recommendation system.\n\n    The VibeCheck client provides a simple interface for:\n    - Collecting restaurant images\n    - Processing and analyzing visual aesthetics\n    - Finding similar restaurants based on vibes\n    - Generating recommendations\n\n    Args:\n        api_key: Optional API key for data collection services (e.g., SerpAPI).\n        model_path: Path to pre-trained model for embeddings.\n        data_dir: Directory for storing restaurant data and images.\n\n    Example:\n        &gt;&gt;&gt; from vibecheck import VibeCheckClient\n        &gt;&gt;&gt; client = VibeCheckClient(api_key=\"your_key\")\n        &gt;&gt;&gt; recommendations = client.get_similar_restaurants(\"Founding Farmers\")\n        &gt;&gt;&gt; print(recommendations)\n    \"\"\"\n\n    def __init__(\n        self,\n        api_key: str | None = None,\n        model_path: Path | None = None,\n        data_dir: Path = Path(\"./data\"),\n    ):\n        \"\"\"Initialize VibeCheck client with configuration.\"\"\"\n        self.api_key = api_key\n        self.model_path = model_path\n        self.data_dir = Path(data_dir)\n        self.data_dir.mkdir(parents=True, exist_ok=True)\n\n        self._index = None\n        self._embeddings = None\n        self._metadata = None\n\n    def collect_restaurant_images(\n        self,\n        restaurant_name: str,\n        search_terms: list[str] | None = None,\n        max_images: int = 10,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Collect images for a restaurant from online sources.\n\n        Args:\n            restaurant_name: Name of the restaurant to collect images for.\n            search_terms: List of search terms (e.g., [\"interior\", \"exterior\"]).\n                Defaults to [\"interior\", \"exterior\", \"environment\"].\n            max_images: Maximum number of images to collect per search term.\n\n        Returns:\n            Dictionary containing collection results with keys:\n                - \"restaurant_name\": Name of the restaurant\n                - \"images_collected\": Number of images successfully collected\n                - \"image_paths\": List of paths to collected images\n                - \"search_terms_used\": Search terms used for collection\n\n        Raises:\n            ValueError: If restaurant_name is empty or invalid.\n            APIError: If API key is missing or invalid.\n\n        Example:\n            &gt;&gt;&gt; client = VibeCheckClient(api_key=\"your_key\")\n            &gt;&gt;&gt; result = client.collect_restaurant_images(\n            ...     restaurant_name=\"Joe's Pizza\",\n            ...     max_images=5\n            ... )\n            &gt;&gt;&gt; print(f\"Collected {result['images_collected']} images\")\n        \"\"\"\n        if not restaurant_name or not restaurant_name.strip():\n            raise ValueError(\"Restaurant name cannot be empty\")\n\n        if search_terms is None:\n            search_terms = [\"interior\", \"exterior\", \"environment\"]\n\n        # Placeholder implementation\n        return {\n            \"restaurant_name\": restaurant_name,\n            \"images_collected\": 0,\n            \"image_paths\": [],\n            \"search_terms_used\": search_terms,\n        }\n\n    def add_restaurant(\n        self, restaurant_name: str, image_paths: list[Path] | None = None\n    ) -&gt; bool:\n        \"\"\"\n        Add a restaurant to the VibeCheck system.\n\n        This method processes restaurant images and adds them to the searchable index.\n\n        Args:\n            restaurant_name: Name of the restaurant to add.\n            image_paths: Optional list of image paths. If not provided,\n                images will be collected automatically.\n\n        Returns:\n            True if restaurant was successfully added, False otherwise.\n\n        Example:\n            &gt;&gt;&gt; client = VibeCheckClient()\n            &gt;&gt;&gt; client.add_restaurant(\"Founding Farmers\")\n            True\n        \"\"\"\n        if not restaurant_name or not restaurant_name.strip():\n            return False\n\n        # Placeholder implementation\n        return True\n\n    def get_similar_restaurants(\n        self,\n        restaurant_name: str,\n        top_k: int = 5,\n        min_similarity: float = 0.0,\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Find restaurants with similar visual aesthetics.\n\n        Args:\n            restaurant_name: Name of the reference restaurant.\n            top_k: Number of similar restaurants to return.\n            min_similarity: Minimum similarity threshold (0.0 to 1.0).\n\n        Returns:\n            List of dictionaries containing similar restaurants, each with:\n                - \"name\": Restaurant name\n                - \"similarity\": Similarity score (0.0 to 1.0)\n                - \"address\": Restaurant address\n                - \"image_url\": URL to representative image\n\n        Raises:\n            ValueError: If restaurant_name is not in the index.\n\n        Example:\n            &gt;&gt;&gt; client = VibeCheckClient()\n            &gt;&gt;&gt; similar = client.get_similar_restaurants(\n            ...     restaurant_name=\"Founding Farmers\",\n            ...     top_k=3\n            ... )\n            &gt;&gt;&gt; for resto in similar:\n            ...     print(f\"{resto['name']}: {resto['similarity']:.2f}\")\n        \"\"\"\n        if not restaurant_name or not restaurant_name.strip():\n            raise ValueError(\"Restaurant name cannot be empty\")\n\n        # Placeholder implementation\n        return []\n\n    def search_by_image(self, image_path: Path, top_k: int = 5) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Find restaurants matching the aesthetic of a provided image.\n\n        Args:\n            image_path: Path to the reference image.\n            top_k: Number of similar restaurants to return.\n\n        Returns:\n            List of dictionaries containing matching restaurants.\n\n        Raises:\n            FileNotFoundError: If image_path does not exist.\n            ValueError: If image cannot be processed.\n\n        Example:\n            &gt;&gt;&gt; client = VibeCheckClient()\n            &gt;&gt;&gt; results = client.search_by_image(\n            ...     image_path=Path(\"my_ideal_restaurant.jpg\"),\n            ...     top_k=5\n            ... )\n            &gt;&gt;&gt; for resto in results:\n            ...     print(resto['name'])\n        \"\"\"\n        if not image_path.exists():\n            raise FileNotFoundError(f\"Image not found: {image_path}\")\n\n        # Placeholder implementation\n        return []\n\n    def get_restaurant_info(self, restaurant_name: str) -&gt; dict[str, Any]:\n        \"\"\"\n        Get detailed information about a restaurant.\n\n        Args:\n            restaurant_name: Name of the restaurant.\n\n        Returns:\n            Dictionary containing restaurant information:\n                - \"name\": Restaurant name\n                - \"address\": Full address\n                - \"rating\": Average rating\n                - \"image_count\": Number of images in database\n                - \"primary_vibe\": Primary aesthetic category\n\n        Raises:\n            ValueError: If restaurant not found in database.\n\n        Example:\n            &gt;&gt;&gt; client = VibeCheckClient()\n            &gt;&gt;&gt; info = client.get_restaurant_info(\"Founding Farmers\")\n            &gt;&gt;&gt; print(info['primary_vibe'])\n        \"\"\"\n        if not restaurant_name or not restaurant_name.strip():\n            raise ValueError(\"Restaurant name cannot be empty\")\n\n        # Placeholder implementation\n        return {\n            \"name\": restaurant_name,\n            \"address\": \"\",\n            \"rating\": 0.0,\n            \"image_count\": 0,\n            \"primary_vibe\": \"unknown\",\n        }\n\n    def list_restaurants(self, limit: int = 100) -&gt; list[str]:\n        \"\"\"\n        List all restaurants in the VibeCheck database.\n\n        Args:\n            limit: Maximum number of restaurants to return.\n\n        Returns:\n            List of restaurant names.\n\n        Example:\n            &gt;&gt;&gt; client = VibeCheckClient()\n            &gt;&gt;&gt; restaurants = client.list_restaurants(limit=10)\n            &gt;&gt;&gt; print(f\"Found {len(restaurants)} restaurants\")\n        \"\"\"\n        # Placeholder implementation\n        return []\n\n    def get_statistics(self) -&gt; dict[str, Any]:\n        \"\"\"\n        Get statistics about the VibeCheck database.\n\n        Returns:\n            Dictionary containing database statistics:\n                - \"total_restaurants\": Total number of restaurants\n                - \"total_images\": Total number of images\n                - \"index_size\": Size of the search index\n                - \"last_updated\": Timestamp of last update\n\n        Example:\n            &gt;&gt;&gt; client = VibeCheckClient()\n            &gt;&gt;&gt; stats = client.get_statistics()\n            &gt;&gt;&gt; print(f\"Database contains {stats['total_restaurants']} restaurants\")\n        \"\"\"\n        return {\n            \"total_restaurants\": 0,\n            \"total_images\": 0,\n            \"index_size\": 0,\n            \"last_updated\": None,\n        }\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.__init__","title":"<code>__init__(api_key=None, model_path=None, data_dir=Path('./data'))</code>","text":"<p>Initialize VibeCheck client with configuration.</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def __init__(\n    self,\n    api_key: str | None = None,\n    model_path: Path | None = None,\n    data_dir: Path = Path(\"./data\"),\n):\n    \"\"\"Initialize VibeCheck client with configuration.\"\"\"\n    self.api_key = api_key\n    self.model_path = model_path\n    self.data_dir = Path(data_dir)\n    self.data_dir.mkdir(parents=True, exist_ok=True)\n\n    self._index = None\n    self._embeddings = None\n    self._metadata = None\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.add_restaurant","title":"<code>add_restaurant(restaurant_name, image_paths=None)</code>","text":"<p>Add a restaurant to the VibeCheck system.</p> <p>This method processes restaurant images and adds them to the searchable index.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_name</code> <code>str</code> <p>Name of the restaurant to add.</p> required <code>image_paths</code> <code>list[Path] | None</code> <p>Optional list of image paths. If not provided, images will be collected automatically.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if restaurant was successfully added, False otherwise.</p> Example <p>client = VibeCheckClient() client.add_restaurant(\"Founding Farmers\") True</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def add_restaurant(\n    self, restaurant_name: str, image_paths: list[Path] | None = None\n) -&gt; bool:\n    \"\"\"\n    Add a restaurant to the VibeCheck system.\n\n    This method processes restaurant images and adds them to the searchable index.\n\n    Args:\n        restaurant_name: Name of the restaurant to add.\n        image_paths: Optional list of image paths. If not provided,\n            images will be collected automatically.\n\n    Returns:\n        True if restaurant was successfully added, False otherwise.\n\n    Example:\n        &gt;&gt;&gt; client = VibeCheckClient()\n        &gt;&gt;&gt; client.add_restaurant(\"Founding Farmers\")\n        True\n    \"\"\"\n    if not restaurant_name or not restaurant_name.strip():\n        return False\n\n    # Placeholder implementation\n    return True\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.collect_restaurant_images","title":"<code>collect_restaurant_images(restaurant_name, search_terms=None, max_images=10)</code>","text":"<p>Collect images for a restaurant from online sources.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_name</code> <code>str</code> <p>Name of the restaurant to collect images for.</p> required <code>search_terms</code> <code>list[str] | None</code> <p>List of search terms (e.g., [\"interior\", \"exterior\"]). Defaults to [\"interior\", \"exterior\", \"environment\"].</p> <code>None</code> <code>max_images</code> <code>int</code> <p>Maximum number of images to collect per search term.</p> <code>10</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing collection results with keys: - \"restaurant_name\": Name of the restaurant - \"images_collected\": Number of images successfully collected - \"image_paths\": List of paths to collected images - \"search_terms_used\": Search terms used for collection</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If restaurant_name is empty or invalid.</p> <code>APIError</code> <p>If API key is missing or invalid.</p> Example <p>client = VibeCheckClient(api_key=\"your_key\") result = client.collect_restaurant_images( ...     restaurant_name=\"Joe's Pizza\", ...     max_images=5 ... ) print(f\"Collected {result['images_collected']} images\")</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def collect_restaurant_images(\n    self,\n    restaurant_name: str,\n    search_terms: list[str] | None = None,\n    max_images: int = 10,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Collect images for a restaurant from online sources.\n\n    Args:\n        restaurant_name: Name of the restaurant to collect images for.\n        search_terms: List of search terms (e.g., [\"interior\", \"exterior\"]).\n            Defaults to [\"interior\", \"exterior\", \"environment\"].\n        max_images: Maximum number of images to collect per search term.\n\n    Returns:\n        Dictionary containing collection results with keys:\n            - \"restaurant_name\": Name of the restaurant\n            - \"images_collected\": Number of images successfully collected\n            - \"image_paths\": List of paths to collected images\n            - \"search_terms_used\": Search terms used for collection\n\n    Raises:\n        ValueError: If restaurant_name is empty or invalid.\n        APIError: If API key is missing or invalid.\n\n    Example:\n        &gt;&gt;&gt; client = VibeCheckClient(api_key=\"your_key\")\n        &gt;&gt;&gt; result = client.collect_restaurant_images(\n        ...     restaurant_name=\"Joe's Pizza\",\n        ...     max_images=5\n        ... )\n        &gt;&gt;&gt; print(f\"Collected {result['images_collected']} images\")\n    \"\"\"\n    if not restaurant_name or not restaurant_name.strip():\n        raise ValueError(\"Restaurant name cannot be empty\")\n\n    if search_terms is None:\n        search_terms = [\"interior\", \"exterior\", \"environment\"]\n\n    # Placeholder implementation\n    return {\n        \"restaurant_name\": restaurant_name,\n        \"images_collected\": 0,\n        \"image_paths\": [],\n        \"search_terms_used\": search_terms,\n    }\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.get_restaurant_info","title":"<code>get_restaurant_info(restaurant_name)</code>","text":"<p>Get detailed information about a restaurant.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_name</code> <code>str</code> <p>Name of the restaurant.</p> required <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing restaurant information: - \"name\": Restaurant name - \"address\": Full address - \"rating\": Average rating - \"image_count\": Number of images in database - \"primary_vibe\": Primary aesthetic category</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If restaurant not found in database.</p> Example <p>client = VibeCheckClient() info = client.get_restaurant_info(\"Founding Farmers\") print(info['primary_vibe'])</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def get_restaurant_info(self, restaurant_name: str) -&gt; dict[str, Any]:\n    \"\"\"\n    Get detailed information about a restaurant.\n\n    Args:\n        restaurant_name: Name of the restaurant.\n\n    Returns:\n        Dictionary containing restaurant information:\n            - \"name\": Restaurant name\n            - \"address\": Full address\n            - \"rating\": Average rating\n            - \"image_count\": Number of images in database\n            - \"primary_vibe\": Primary aesthetic category\n\n    Raises:\n        ValueError: If restaurant not found in database.\n\n    Example:\n        &gt;&gt;&gt; client = VibeCheckClient()\n        &gt;&gt;&gt; info = client.get_restaurant_info(\"Founding Farmers\")\n        &gt;&gt;&gt; print(info['primary_vibe'])\n    \"\"\"\n    if not restaurant_name or not restaurant_name.strip():\n        raise ValueError(\"Restaurant name cannot be empty\")\n\n    # Placeholder implementation\n    return {\n        \"name\": restaurant_name,\n        \"address\": \"\",\n        \"rating\": 0.0,\n        \"image_count\": 0,\n        \"primary_vibe\": \"unknown\",\n    }\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.get_similar_restaurants","title":"<code>get_similar_restaurants(restaurant_name, top_k=5, min_similarity=0.0)</code>","text":"<p>Find restaurants with similar visual aesthetics.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_name</code> <code>str</code> <p>Name of the reference restaurant.</p> required <code>top_k</code> <code>int</code> <p>Number of similar restaurants to return.</p> <code>5</code> <code>min_similarity</code> <code>float</code> <p>Minimum similarity threshold (0.0 to 1.0).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of dictionaries containing similar restaurants, each with: - \"name\": Restaurant name - \"similarity\": Similarity score (0.0 to 1.0) - \"address\": Restaurant address - \"image_url\": URL to representative image</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If restaurant_name is not in the index.</p> Example <p>client = VibeCheckClient() similar = client.get_similar_restaurants( ...     restaurant_name=\"Founding Farmers\", ...     top_k=3 ... ) for resto in similar: ...     print(f\"{resto['name']}: {resto['similarity']:.2f}\")</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def get_similar_restaurants(\n    self,\n    restaurant_name: str,\n    top_k: int = 5,\n    min_similarity: float = 0.0,\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Find restaurants with similar visual aesthetics.\n\n    Args:\n        restaurant_name: Name of the reference restaurant.\n        top_k: Number of similar restaurants to return.\n        min_similarity: Minimum similarity threshold (0.0 to 1.0).\n\n    Returns:\n        List of dictionaries containing similar restaurants, each with:\n            - \"name\": Restaurant name\n            - \"similarity\": Similarity score (0.0 to 1.0)\n            - \"address\": Restaurant address\n            - \"image_url\": URL to representative image\n\n    Raises:\n        ValueError: If restaurant_name is not in the index.\n\n    Example:\n        &gt;&gt;&gt; client = VibeCheckClient()\n        &gt;&gt;&gt; similar = client.get_similar_restaurants(\n        ...     restaurant_name=\"Founding Farmers\",\n        ...     top_k=3\n        ... )\n        &gt;&gt;&gt; for resto in similar:\n        ...     print(f\"{resto['name']}: {resto['similarity']:.2f}\")\n    \"\"\"\n    if not restaurant_name or not restaurant_name.strip():\n        raise ValueError(\"Restaurant name cannot be empty\")\n\n    # Placeholder implementation\n    return []\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.get_statistics","title":"<code>get_statistics()</code>","text":"<p>Get statistics about the VibeCheck database.</p> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary containing database statistics: - \"total_restaurants\": Total number of restaurants - \"total_images\": Total number of images - \"index_size\": Size of the search index - \"last_updated\": Timestamp of last update</p> Example <p>client = VibeCheckClient() stats = client.get_statistics() print(f\"Database contains {stats['total_restaurants']} restaurants\")</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def get_statistics(self) -&gt; dict[str, Any]:\n    \"\"\"\n    Get statistics about the VibeCheck database.\n\n    Returns:\n        Dictionary containing database statistics:\n            - \"total_restaurants\": Total number of restaurants\n            - \"total_images\": Total number of images\n            - \"index_size\": Size of the search index\n            - \"last_updated\": Timestamp of last update\n\n    Example:\n        &gt;&gt;&gt; client = VibeCheckClient()\n        &gt;&gt;&gt; stats = client.get_statistics()\n        &gt;&gt;&gt; print(f\"Database contains {stats['total_restaurants']} restaurants\")\n    \"\"\"\n    return {\n        \"total_restaurants\": 0,\n        \"total_images\": 0,\n        \"index_size\": 0,\n        \"last_updated\": None,\n    }\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.list_restaurants","title":"<code>list_restaurants(limit=100)</code>","text":"<p>List all restaurants in the VibeCheck database.</p> <p>Parameters:</p> Name Type Description Default <code>limit</code> <code>int</code> <p>Maximum number of restaurants to return.</p> <code>100</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of restaurant names.</p> Example <p>client = VibeCheckClient() restaurants = client.list_restaurants(limit=10) print(f\"Found {len(restaurants)} restaurants\")</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def list_restaurants(self, limit: int = 100) -&gt; list[str]:\n    \"\"\"\n    List all restaurants in the VibeCheck database.\n\n    Args:\n        limit: Maximum number of restaurants to return.\n\n    Returns:\n        List of restaurant names.\n\n    Example:\n        &gt;&gt;&gt; client = VibeCheckClient()\n        &gt;&gt;&gt; restaurants = client.list_restaurants(limit=10)\n        &gt;&gt;&gt; print(f\"Found {len(restaurants)} restaurants\")\n    \"\"\"\n    # Placeholder implementation\n    return []\n</code></pre>"},{"location":"reference/vibecheck/client/#vibecheck.client.VibeCheckClient.search_by_image","title":"<code>search_by_image(image_path, top_k=5)</code>","text":"<p>Find restaurants matching the aesthetic of a provided image.</p> <p>Parameters:</p> Name Type Description Default <code>image_path</code> <code>Path</code> <p>Path to the reference image.</p> required <code>top_k</code> <code>int</code> <p>Number of similar restaurants to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of dictionaries containing matching restaurants.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If image_path does not exist.</p> <code>ValueError</code> <p>If image cannot be processed.</p> Example <p>client = VibeCheckClient() results = client.search_by_image( ...     image_path=Path(\"my_ideal_restaurant.jpg\"), ...     top_k=5 ... ) for resto in results: ...     print(resto['name'])</p> Source code in <code>src/vibecheck/client.py</code> <pre><code>def search_by_image(self, image_path: Path, top_k: int = 5) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Find restaurants matching the aesthetic of a provided image.\n\n    Args:\n        image_path: Path to the reference image.\n        top_k: Number of similar restaurants to return.\n\n    Returns:\n        List of dictionaries containing matching restaurants.\n\n    Raises:\n        FileNotFoundError: If image_path does not exist.\n        ValueError: If image cannot be processed.\n\n    Example:\n        &gt;&gt;&gt; client = VibeCheckClient()\n        &gt;&gt;&gt; results = client.search_by_image(\n        ...     image_path=Path(\"my_ideal_restaurant.jpg\"),\n        ...     top_k=5\n        ... )\n        &gt;&gt;&gt; for resto in results:\n        ...     print(resto['name'])\n    \"\"\"\n    if not image_path.exists():\n        raise FileNotFoundError(f\"Image not found: {image_path}\")\n\n    # Placeholder implementation\n    return []\n</code></pre>"},{"location":"reference/vibecheck/database/","title":"database","text":""},{"location":"reference/vibecheck/database/#vibecheck.database","title":"<code>vibecheck.database</code>","text":"<p>Database operations for VibeCheck.</p>"},{"location":"reference/vibecheck/database/#vibecheck.database.RestaurantDatabase","title":"<code>RestaurantDatabase</code>","text":"<p>Interface for restaurant database operations.</p> Example <p>db = RestaurantDatabase(\"data/restaurants_info/restaurants.db\") info = db.get_restaurant(\"some_id\") print(info['name'])</p> Source code in <code>src/vibecheck/database.py</code> <pre><code>class RestaurantDatabase:\n    \"\"\"\n    Interface for restaurant database operations.\n\n    Example:\n        &gt;&gt;&gt; db = RestaurantDatabase(\"data/restaurants_info/restaurants.db\")\n        &gt;&gt;&gt; info = db.get_restaurant(\"some_id\")\n        &gt;&gt;&gt; print(info['name'])\n    \"\"\"\n\n    def __init__(self, db_path: Path = Path(\"data/restaurants_info/restaurants.db\")):\n        \"\"\"Initialize database connection.\"\"\"\n        self.db_path = Path(db_path)\n        logger.info(f\"Initialized database connection: {self.db_path}\")\n\n        if not self.db_path.exists():\n            logger.warning(f\"Database file does not exist: {self.db_path}\")\n\n    @contextmanager\n    def get_connection(self):\n        \"\"\"Context manager for database connections.\"\"\"\n        logger.debug(f\"Opening database connection: {self.db_path}\")\n        conn = sqlite3.connect(self.db_path)\n        try:\n            yield conn\n        finally:\n            conn.close()\n            logger.debug(\"Database connection closed\")\n\n    def get_restaurant(self, restaurant_id: str) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Get restaurant information by ID.\n\n        Args:\n            restaurant_id: Unique restaurant identifier.\n\n        Returns:\n            Dictionary with restaurant info or None if not found.\n        \"\"\"\n        logger.debug(f\"Fetching restaurant: {restaurant_id}\")\n\n        try:\n            with self.get_connection() as conn:\n                row = conn.execute(\n                    \"SELECT id, name, rating, address, image_url, categories, review_snippet \"\n                    \"FROM restaurants WHERE id=?\",\n                    (restaurant_id,),\n                ).fetchone()\n\n            if not row:\n                logger.debug(f\"Restaurant not found: {restaurant_id}\")\n                return None\n\n            result = {\n                \"id\": row[0],\n                \"name\": row[1],\n                \"rating\": row[2],\n                \"address\": row[3],\n                \"image_url\": row[4],\n                \"categories\": row[5],\n                \"review_snippet\": row[6],\n            }\n            logger.debug(f\"Found restaurant: {result['name']}\")\n            return result\n\n        except sqlite3.Error as e:\n            logger.error(f\"Database error fetching restaurant {restaurant_id}: {e}\")\n            return None\n\n    def get_all_restaurants(self) -&gt; list[dict[str, Any]]:\n        \"\"\"Get all restaurants from database.\"\"\"\n        logger.info(\"Fetching all restaurants from database\")\n\n        try:\n            with self.get_connection() as conn:\n                rows = conn.execute(\n                    \"SELECT id, name, rating, review_snippet FROM restaurants\"\n                ).fetchall()\n\n            restaurants = [\n                {\n                    \"id\": row[0],\n                    \"name\": row[1],\n                    \"rating\": row[2],\n                    \"review_snippet\": row[3],\n                }\n                for row in rows\n            ]\n\n            logger.info(f\"Retrieved {len(restaurants)} restaurants\")\n            return restaurants\n\n        except sqlite3.Error as e:\n            logger.error(f\"Database error fetching all restaurants: {e}\")\n            return []\n</code></pre>"},{"location":"reference/vibecheck/database/#vibecheck.database.RestaurantDatabase.__init__","title":"<code>__init__(db_path=Path('data/restaurants_info/restaurants.db'))</code>","text":"<p>Initialize database connection.</p> Source code in <code>src/vibecheck/database.py</code> <pre><code>def __init__(self, db_path: Path = Path(\"data/restaurants_info/restaurants.db\")):\n    \"\"\"Initialize database connection.\"\"\"\n    self.db_path = Path(db_path)\n    logger.info(f\"Initialized database connection: {self.db_path}\")\n\n    if not self.db_path.exists():\n        logger.warning(f\"Database file does not exist: {self.db_path}\")\n</code></pre>"},{"location":"reference/vibecheck/database/#vibecheck.database.RestaurantDatabase.get_all_restaurants","title":"<code>get_all_restaurants()</code>","text":"<p>Get all restaurants from database.</p> Source code in <code>src/vibecheck/database.py</code> <pre><code>def get_all_restaurants(self) -&gt; list[dict[str, Any]]:\n    \"\"\"Get all restaurants from database.\"\"\"\n    logger.info(\"Fetching all restaurants from database\")\n\n    try:\n        with self.get_connection() as conn:\n            rows = conn.execute(\n                \"SELECT id, name, rating, review_snippet FROM restaurants\"\n            ).fetchall()\n\n        restaurants = [\n            {\n                \"id\": row[0],\n                \"name\": row[1],\n                \"rating\": row[2],\n                \"review_snippet\": row[3],\n            }\n            for row in rows\n        ]\n\n        logger.info(f\"Retrieved {len(restaurants)} restaurants\")\n        return restaurants\n\n    except sqlite3.Error as e:\n        logger.error(f\"Database error fetching all restaurants: {e}\")\n        return []\n</code></pre>"},{"location":"reference/vibecheck/database/#vibecheck.database.RestaurantDatabase.get_connection","title":"<code>get_connection()</code>","text":"<p>Context manager for database connections.</p> Source code in <code>src/vibecheck/database.py</code> <pre><code>@contextmanager\ndef get_connection(self):\n    \"\"\"Context manager for database connections.\"\"\"\n    logger.debug(f\"Opening database connection: {self.db_path}\")\n    conn = sqlite3.connect(self.db_path)\n    try:\n        yield conn\n    finally:\n        conn.close()\n        logger.debug(\"Database connection closed\")\n</code></pre>"},{"location":"reference/vibecheck/database/#vibecheck.database.RestaurantDatabase.get_restaurant","title":"<code>get_restaurant(restaurant_id)</code>","text":"<p>Get restaurant information by ID.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_id</code> <code>str</code> <p>Unique restaurant identifier.</p> required <p>Returns:</p> Type Description <code>dict[str, Any] | None</code> <p>Dictionary with restaurant info or None if not found.</p> Source code in <code>src/vibecheck/database.py</code> <pre><code>def get_restaurant(self, restaurant_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get restaurant information by ID.\n\n    Args:\n        restaurant_id: Unique restaurant identifier.\n\n    Returns:\n        Dictionary with restaurant info or None if not found.\n    \"\"\"\n    logger.debug(f\"Fetching restaurant: {restaurant_id}\")\n\n    try:\n        with self.get_connection() as conn:\n            row = conn.execute(\n                \"SELECT id, name, rating, address, image_url, categories, review_snippet \"\n                \"FROM restaurants WHERE id=?\",\n                (restaurant_id,),\n            ).fetchone()\n\n        if not row:\n            logger.debug(f\"Restaurant not found: {restaurant_id}\")\n            return None\n\n        result = {\n            \"id\": row[0],\n            \"name\": row[1],\n            \"rating\": row[2],\n            \"address\": row[3],\n            \"image_url\": row[4],\n            \"categories\": row[5],\n            \"review_snippet\": row[6],\n        }\n        logger.debug(f\"Found restaurant: {result['name']}\")\n        return result\n\n    except sqlite3.Error as e:\n        logger.error(f\"Database error fetching restaurant {restaurant_id}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/vibecheck/logging_config/","title":"logging_config","text":""},{"location":"reference/vibecheck/logging_config/#vibecheck.logging_config","title":"<code>vibecheck.logging_config</code>","text":"<p>Logging configuration for VibeCheck application.</p>"},{"location":"reference/vibecheck/logging_config/#vibecheck.logging_config.get_logger","title":"<code>get_logger(name)</code>","text":"<p>Get a logger instance for a specific module.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the module (typically name).</p> required <p>Returns:</p> Type Description <code>Logger</code> <p>Logger instance.</p> Example <p>from vibecheck.logging_config import get_logger logger = get_logger(name) logger.info(\"Processing started\")</p> Source code in <code>src/vibecheck/logging_config.py</code> <pre><code>def get_logger(name: str) -&gt; logging.Logger:\n    \"\"\"\n    Get a logger instance for a specific module.\n\n    Args:\n        name: Name of the module (typically __name__).\n\n    Returns:\n        Logger instance.\n\n    Example:\n        &gt;&gt;&gt; from vibecheck.logging_config import get_logger\n        &gt;&gt;&gt; logger = get_logger(__name__)\n        &gt;&gt;&gt; logger.info(\"Processing started\")\n    \"\"\"\n    return logging.getLogger(f\"vibecheck.{name}\")\n</code></pre>"},{"location":"reference/vibecheck/logging_config/#vibecheck.logging_config.setup_logging","title":"<code>setup_logging(level=logging.INFO, log_file=None, log_format=None)</code>","text":"<p>Configure logging for the VibeCheck application.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>int</code> <p>Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).</p> <code>INFO</code> <code>log_file</code> <code>Path | None</code> <p>Optional path to log file. If None, logs only to console.</p> <code>None</code> <code>log_format</code> <code>str | None</code> <p>Optional custom log format string.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>Configured logger instance.</p> Example <p>from vibecheck.logging_config import setup_logging logger = setup_logging(level=logging.DEBUG) logger.info(\"Application started\")</p> Source code in <code>src/vibecheck/logging_config.py</code> <pre><code>def setup_logging(\n    level: int = logging.INFO,\n    log_file: Path | None = None,\n    log_format: str | None = None,\n) -&gt; logging.Logger:\n    \"\"\"\n    Configure logging for the VibeCheck application.\n\n    Args:\n        level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).\n        log_file: Optional path to log file. If None, logs only to console.\n        log_format: Optional custom log format string.\n\n    Returns:\n        Configured logger instance.\n\n    Example:\n        &gt;&gt;&gt; from vibecheck.logging_config import setup_logging\n        &gt;&gt;&gt; logger = setup_logging(level=logging.DEBUG)\n        &gt;&gt;&gt; logger.info(\"Application started\")\n    \"\"\"\n    if log_format is None:\n        log_format = \"%(asctime)s | %(levelname)-8s | %(name)s | %(message)s\"\n\n    # Create formatter\n    formatter = logging.Formatter(log_format, datefmt=\"%Y-%m-%d %H:%M:%S\")\n\n    # Get root logger for vibecheck\n    logger = logging.getLogger(\"vibecheck\")\n    logger.setLevel(level)\n\n    # Remove existing handlers to avoid duplicates\n    logger.handlers.clear()\n\n    # Console handler\n    console_handler = logging.StreamHandler(sys.stdout)\n    console_handler.setLevel(level)\n    console_handler.setFormatter(formatter)\n    logger.addHandler(console_handler)\n\n    # File handler (optional)\n    if log_file:\n        log_file = Path(log_file)\n        log_file.parent.mkdir(parents=True, exist_ok=True)\n\n        file_handler = logging.FileHandler(log_file)\n        file_handler.setLevel(level)\n        file_handler.setFormatter(formatter)\n        logger.addHandler(file_handler)\n        logger.info(f\"Logging to file: {log_file}\")\n\n    return logger\n</code></pre>"},{"location":"reference/vibecheck/mlflow_config/","title":"mlflow_config","text":""},{"location":"reference/vibecheck/mlflow_config/#vibecheck.mlflow_config","title":"<code>vibecheck.mlflow_config</code>","text":"<p>MLFlow configuration and utilities for VibeCheck experiment tracking.</p>"},{"location":"reference/vibecheck/mlflow_config/#vibecheck.mlflow_config.MLFlowConfig","title":"<code>MLFlowConfig</code>","text":"<p>Configuration class for MLFlow tracking.</p> Source code in <code>src/vibecheck/mlflow_config.py</code> <pre><code>class MLFlowConfig:\n    \"\"\"Configuration class for MLFlow tracking.\"\"\"\n\n    # Default tracking URI (can be overridden by environment variable)\n    DEFAULT_TRACKING_URI = os.getenv(\"MLFLOW_TRACKING_URI\", \"http://localhost:5000\")\n\n    # Experiment names\n    EMBEDDING_EXPERIMENT = \"vibecheck-embeddings\"\n    VIBE_MAPPING_EXPERIMENT = \"vibecheck-vibe-mapping\"\n    RECOMMENDATION_EXPERIMENT = \"vibecheck-recommendations\"\n\n    # Artifact paths\n    ARTIFACTS_DIR = Path(\"mlruns/artifacts\")\n\n    @classmethod\n    def setup_mlflow(cls, tracking_uri: str | None = None) -&gt; None:\n        \"\"\"\n        Initialize MLFlow tracking configuration.\n\n        Args:\n            tracking_uri: Optional custom tracking URI. If not provided, uses default.\n        \"\"\"\n        uri = tracking_uri or cls.DEFAULT_TRACKING_URI\n        mlflow.set_tracking_uri(uri)\n        print(f\"MLFlow tracking URI set to: {uri}\")\n\n        # Create artifacts directory if it doesn't exist\n        cls.ARTIFACTS_DIR.mkdir(parents=True, exist_ok=True)\n\n    @classmethod\n    def create_experiment(\n        cls, experiment_name: str, tags: dict[str, Any | None] | None = None\n    ) -&gt; str:\n        \"\"\"\n        Create an MLFlow experiment if it doesn't exist.\n\n        Args:\n            experiment_name: Name of the experiment\n            tags: Optional tags for the experiment\n\n        Returns:\n            Experiment ID\n        \"\"\"\n        client = MlflowClient()\n\n        try:\n            experiment = client.get_experiment_by_name(experiment_name)\n            if experiment:\n                return str(experiment.experiment_id)\n        except Exception:\n            pass\n\n        # Create new experiment\n        experiment_id = mlflow.create_experiment(experiment_name, tags=tags or {})\n        print(f\"Created experiment '{experiment_name}' with ID: {experiment_id}\")\n        return str(experiment_id)\n\n    @classmethod\n    def get_or_create_experiment(cls, experiment_name: str) -&gt; str:\n        \"\"\"\n        Get existing experiment ID or create new one.\n\n        Args:\n            experiment_name: Name of the experiment\n\n        Returns:\n            Experiment ID\n        \"\"\"\n        experiment = mlflow.get_experiment_by_name(experiment_name)\n        if experiment:\n            return str(experiment.experiment_id)\n        return cls.create_experiment(experiment_name)\n</code></pre>"},{"location":"reference/vibecheck/mlflow_config/#vibecheck.mlflow_config.MLFlowConfig.create_experiment","title":"<code>create_experiment(experiment_name, tags=None)</code>  <code>classmethod</code>","text":"<p>Create an MLFlow experiment if it doesn't exist.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> <p>Name of the experiment</p> required <code>tags</code> <code>dict[str, Any | None] | None</code> <p>Optional tags for the experiment</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Experiment ID</p> Source code in <code>src/vibecheck/mlflow_config.py</code> <pre><code>@classmethod\ndef create_experiment(\n    cls, experiment_name: str, tags: dict[str, Any | None] | None = None\n) -&gt; str:\n    \"\"\"\n    Create an MLFlow experiment if it doesn't exist.\n\n    Args:\n        experiment_name: Name of the experiment\n        tags: Optional tags for the experiment\n\n    Returns:\n        Experiment ID\n    \"\"\"\n    client = MlflowClient()\n\n    try:\n        experiment = client.get_experiment_by_name(experiment_name)\n        if experiment:\n            return str(experiment.experiment_id)\n    except Exception:\n        pass\n\n    # Create new experiment\n    experiment_id = mlflow.create_experiment(experiment_name, tags=tags or {})\n    print(f\"Created experiment '{experiment_name}' with ID: {experiment_id}\")\n    return str(experiment_id)\n</code></pre>"},{"location":"reference/vibecheck/mlflow_config/#vibecheck.mlflow_config.MLFlowConfig.get_or_create_experiment","title":"<code>get_or_create_experiment(experiment_name)</code>  <code>classmethod</code>","text":"<p>Get existing experiment ID or create new one.</p> <p>Parameters:</p> Name Type Description Default <code>experiment_name</code> <code>str</code> <p>Name of the experiment</p> required <p>Returns:</p> Type Description <code>str</code> <p>Experiment ID</p> Source code in <code>src/vibecheck/mlflow_config.py</code> <pre><code>@classmethod\ndef get_or_create_experiment(cls, experiment_name: str) -&gt; str:\n    \"\"\"\n    Get existing experiment ID or create new one.\n\n    Args:\n        experiment_name: Name of the experiment\n\n    Returns:\n        Experiment ID\n    \"\"\"\n    experiment = mlflow.get_experiment_by_name(experiment_name)\n    if experiment:\n        return str(experiment.experiment_id)\n    return cls.create_experiment(experiment_name)\n</code></pre>"},{"location":"reference/vibecheck/mlflow_config/#vibecheck.mlflow_config.MLFlowConfig.setup_mlflow","title":"<code>setup_mlflow(tracking_uri=None)</code>  <code>classmethod</code>","text":"<p>Initialize MLFlow tracking configuration.</p> <p>Parameters:</p> Name Type Description Default <code>tracking_uri</code> <code>str | None</code> <p>Optional custom tracking URI. If not provided, uses default.</p> <code>None</code> Source code in <code>src/vibecheck/mlflow_config.py</code> <pre><code>@classmethod\ndef setup_mlflow(cls, tracking_uri: str | None = None) -&gt; None:\n    \"\"\"\n    Initialize MLFlow tracking configuration.\n\n    Args:\n        tracking_uri: Optional custom tracking URI. If not provided, uses default.\n    \"\"\"\n    uri = tracking_uri or cls.DEFAULT_TRACKING_URI\n    mlflow.set_tracking_uri(uri)\n    print(f\"MLFlow tracking URI set to: {uri}\")\n\n    # Create artifacts directory if it doesn't exist\n    cls.ARTIFACTS_DIR.mkdir(parents=True, exist_ok=True)\n</code></pre>"},{"location":"reference/vibecheck/mlflow_config/#vibecheck.mlflow_config.init_mlflow","title":"<code>init_mlflow(tracking_uri=None)</code>","text":"<p>Initialize MLFlow tracking with default experiments.</p> <p>Parameters:</p> Name Type Description Default <code>tracking_uri</code> <code>str | None</code> <p>Optional custom tracking URI</p> <code>None</code> Source code in <code>src/vibecheck/mlflow_config.py</code> <pre><code>def init_mlflow(tracking_uri: str | None = None) -&gt; None:\n    \"\"\"\n    Initialize MLFlow tracking with default experiments.\n\n    Args:\n        tracking_uri: Optional custom tracking URI\n    \"\"\"\n    MLFlowConfig.setup_mlflow(tracking_uri)\n\n    # Create default experiments\n    MLFlowConfig.get_or_create_experiment(MLFlowConfig.EMBEDDING_EXPERIMENT)\n    MLFlowConfig.get_or_create_experiment(MLFlowConfig.VIBE_MAPPING_EXPERIMENT)\n    MLFlowConfig.get_or_create_experiment(MLFlowConfig.RECOMMENDATION_EXPERIMENT)\n\n    print(\"MLFlow initialized with default experiments\")\n</code></pre>"},{"location":"reference/vibecheck/recommender/","title":"recommender","text":""},{"location":"reference/vibecheck/recommender/#vibecheck.recommender","title":"<code>vibecheck.recommender</code>","text":"<p>Core recommendation engine for VibeCheck.</p>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender","title":"<code>VibeCheckRecommender</code>","text":"<p>Main recommendation engine - same as before but with updated paths.</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>class VibeCheckRecommender:\n    \"\"\"Main recommendation engine - same as before but with updated paths.\"\"\"\n\n    def __init__(\n        self,\n        db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n        image_dir: Path = Path(\"data/images/sample_images\"),\n        faiss_index_path: Path = Path(\"data/embeddings/vibecheck_index.faiss\"),\n        meta_ids_path: Path = Path(\"data/restaurants_info/meta_ids.npy\"),\n    ):\n        \"\"\"Initialize with new data paths.\"\"\"\n        logger.info(\"Initializing VibeCheckRecommender\")\n        logger.debug(f\"Database path: {db_path}\")\n        logger.debug(f\"Image directory: {image_dir}\")\n        logger.debug(f\"FAISS index: {faiss_index_path}\")\n        logger.debug(f\"Meta IDs: {meta_ids_path}\")\n\n        self.db = RestaurantDatabase(db_path)\n        self.db_path = db_path  # Store for get_restaurant_info\n        self.image_dir = Path(image_dir)\n\n        # Load models\n        logger.info(\"Loading models...\")\n        self.text_model = ModelCache.get_text_model()\n        self.clip_model, self.clip_preprocess = ModelCache.get_clip_model()\n        self.device = ModelCache.get_device()\n\n        # Load search index\n        logger.info(\"Loading FAISS index...\")\n        try:\n            self.index = faiss.read_index(str(faiss_index_path))\n            self.meta_ids = np.load(str(meta_ids_path))\n            logger.info(f\"Loaded index with {len(self.meta_ids)} entries\")\n        except Exception as e:\n            logger.error(f\"Failed to load index: {e}\")\n            raise\n\n    def encode_text(self, text: str) -&gt; np.ndarray:\n        \"\"\"\n        Encode text query into embedding vector.\n\n        Args:\n            text: Text description of desired vibe.\n\n        Returns:\n            Normalized embedding vector of shape (384,).\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; vector = recommender.encode_text(\"cozy cafe\")\n            &gt;&gt;&gt; vector.shape\n            (384,)\n        \"\"\"\n        logger.debug(\n            f\"Encoding text: {text[:50]}...\"\n            if len(text) &gt; 50\n            else f\"Encoding text: {text}\"\n        )\n        return self.text_model.encode(\n            text, convert_to_numpy=True, normalize_embeddings=True\n        )\n\n    def encode_image(self, image: Image.Image) -&gt; np.ndarray:\n        \"\"\"\n        Encode image into CLIP embedding vector.\n\n        Args:\n            image: PIL Image of desired aesthetic.\n\n        Returns:\n            Normalized embedding vector of shape (512,).\n\n        Example:\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; img = Image.open(\"restaurant.jpg\")\n            &gt;&gt;&gt; vector = recommender.encode_image(img)\n            &gt;&gt;&gt; vector.shape\n            (512,)\n        \"\"\"\n        logger.debug(\"Encoding image...\")\n        img_tensor = self.clip_preprocess(image).unsqueeze(0).to(self.device)\n\n        with torch.no_grad():\n            img_vec = self.clip_model.encode_image(img_tensor)\n\n        img_vec /= img_vec.norm(dim=-1, keepdim=True)\n        return img_vec.cpu().numpy()[0]\n\n    def encode_query(\n        self, text: str | None = None, image: Image.Image | None = None\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Encode a multimodal query (text and/or image) into a combined embedding.\n\n        Args:\n            text: Optional text description of desired vibe.\n            image: Optional PIL Image of desired aesthetic.\n\n        Returns:\n            Combined embedding vector of shape (896,) = (384 text + 512 image).\n\n        Raises:\n            ValueError: If both text and image are None.\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; # Text only\n            &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\")\n            &gt;&gt;&gt; # Image only\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n            &gt;&gt;&gt; vec = recommender.encode_query(image=img)\n            &gt;&gt;&gt; # Both\n            &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\", image=img)\n        \"\"\"\n        if text is None and image is None:\n            logger.error(\"encode_query called with no text or image\")\n            raise ValueError(\"Must provide either text or image query\")\n\n        logger.info(f\"Encoding query - text: {bool(text)}, image: {bool(image)}\")\n\n        # Encode text (or use zeros if not provided)\n        text_vec = self.encode_text(text) if text else np.zeros((384,))\n\n        # Encode image (or use zeros if not provided)\n        image_vec = self.encode_image(image) if image else np.zeros((512,))\n\n        # Concatenate into single vector\n        combined = np.concatenate([text_vec, image_vec]).astype(\"float32\")\n        return combined[None, :]  # Add batch dimension\n\n    def search(\n        self, query_vector: np.ndarray, top_k: int = 5\n    ) -&gt; list[tuple[str, float]]:\n        \"\"\"\n        Search the FAISS index for similar restaurants.\n\n        Args:\n            query_vector: Query embedding vector of shape (1, 896).\n            top_k: Number of top results to return.\n\n        Returns:\n            List of (restaurant_id, distance) tuples.\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; query_vec = recommender.encode_query(text=\"cozy cafe\")\n            &gt;&gt;&gt; results = recommender.search(query_vec, top_k=5)\n            &gt;&gt;&gt; for rid, distance in results:\n            ...     print(f\"Restaurant {rid}: distance={distance:.4f}\")\n        \"\"\"\n        logger.debug(f\"Searching index for top {top_k} results\")\n        distances, indices = self.index.search(query_vector, top_k)\n\n        results = []\n        for idx, distance in zip(indices[0], distances[0], strict=False):\n            restaurant_id = self.meta_ids[idx]\n            results.append((restaurant_id, float(distance)))\n\n        logger.debug(f\"Found {len(results)} results\")\n        return results\n\n    def get_restaurant_info(self, restaurant_id: str) -&gt; dict[str, Any] | None:\n        \"\"\"\n        Get detailed information about a restaurant from the database.\n\n        Args:\n            restaurant_id: Unique restaurant identifier.\n\n        Returns:\n            Dictionary with restaurant details or None if not found.\n            Keys: 'id', 'name', 'rating', 'address', 'image_url', 'image_path'\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; info = recommender.get_restaurant_info(\"some_id\")\n            &gt;&gt;&gt; print(info['name'])\n            &gt;&gt;&gt; print(info['rating'])\n        \"\"\"\n        logger.debug(f\"Fetching restaurant info: {restaurant_id}\")\n        try:\n            with sqlite3.connect(self.db_path) as conn:\n                row = conn.execute(\n                    \"SELECT name, rating, address, image_url FROM restaurants WHERE id=?\",\n                    (restaurant_id,),\n                ).fetchone()\n\n            if not row:\n                logger.debug(f\"Restaurant not found: {restaurant_id}\")\n                return None\n\n            name, rating, address, image_url = row\n            image_path = self.image_dir / f\"{restaurant_id}.jpg\"\n\n            logger.debug(f\"Found restaurant: {name}\")\n            return {\n                \"id\": restaurant_id,\n                \"name\": name,\n                \"rating\": rating,\n                \"address\": address,\n                \"image_url\": image_url,\n                \"image_path\": str(image_path) if image_path.exists() else None,\n            }\n\n        except Exception as e:\n            logger.error(f\"Error fetching restaurant {restaurant_id}: {e}\")\n            return None\n\n    def search_by_text(self, text: str, top_k: int = 5) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Search for restaurants matching a text description.\n\n        Args:\n            text: Description of desired vibe (e.g., \"cozy cafe with plants\").\n            top_k: Number of results to return.\n\n        Returns:\n            List of restaurant dictionaries with full information.\n\n        Example:\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; results = recommender.search_by_text(\"cozy cafe with plants\", top_k=3)\n            &gt;&gt;&gt; for resto in results:\n            ...     print(f\"{resto['name']}: {resto['rating']} stars\")\n        \"\"\"\n        logger.info(\n            f\"Text search: '{text[:50]}...' (top_k={top_k})\"\n            if len(text) &gt; 50\n            else f\"Text search: '{text}' (top_k={top_k})\"\n        )\n\n        query_vec = self.encode_query(text=text)\n        search_results = self.search(query_vec, top_k=top_k)\n\n        restaurants = []\n        for restaurant_id, distance in search_results:\n            info = self.get_restaurant_info(restaurant_id)\n            if info:\n                info[\"distance\"] = distance\n                info[\"similarity\"] = 1.0 / (\n                    1.0 + distance\n                )  # Convert distance to similarity\n                restaurants.append(info)\n\n        logger.info(f\"Returning {len(restaurants)} results\")\n        return restaurants\n\n    def search_by_image(\n        self, image: Image.Image, top_k: int = 5\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Search for restaurants matching an image aesthetic.\n\n        Args:\n            image: PIL Image of desired aesthetic.\n            top_k: Number of results to return.\n\n        Returns:\n            List of restaurant dictionaries with full information.\n\n        Example:\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; img = Image.open(\"ideal_restaurant.jpg\")\n            &gt;&gt;&gt; results = recommender.search_by_image(img, top_k=3)\n            &gt;&gt;&gt; for resto in results:\n            ...     print(resto['name'])\n        \"\"\"\n        logger.info(f\"Image search (top_k={top_k})\")\n\n        query_vec = self.encode_query(image=image)\n        search_results = self.search(query_vec, top_k=top_k)\n\n        restaurants = []\n        for restaurant_id, distance in search_results:\n            info = self.get_restaurant_info(restaurant_id)\n            if info:\n                info[\"distance\"] = distance\n                info[\"similarity\"] = 1.0 / (1.0 + distance)\n                restaurants.append(info)\n\n        logger.info(f\"Returning {len(restaurants)} results\")\n        return restaurants\n\n    def search_multimodal(\n        self, text: str | None = None, image: Image.Image | None = None, top_k: int = 5\n    ) -&gt; list[dict[str, Any]]:\n        \"\"\"\n        Search using both text and image simultaneously.\n\n        Args:\n            text: Optional text description.\n            image: Optional PIL Image.\n            top_k: Number of results to return.\n\n        Returns:\n            List of restaurant dictionaries with full information.\n\n        Example:\n            &gt;&gt;&gt; from PIL import Image\n            &gt;&gt;&gt; recommender = VibeCheckRecommender()\n            &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n            &gt;&gt;&gt; results = recommender.search_multimodal(\n            ...     text=\"cozy atmosphere\",\n            ...     image=img,\n            ...     top_k=5\n            ... )\n        \"\"\"\n        logger.info(\n            f\"Multimodal search (text={bool(text)}, image={bool(image)}, top_k={top_k})\"\n        )\n\n        query_vec = self.encode_query(text=text, image=image)\n        search_results = self.search(query_vec, top_k=top_k)\n\n        restaurants = []\n        for restaurant_id, distance in search_results:\n            info = self.get_restaurant_info(restaurant_id)\n            if info:\n                info[\"distance\"] = distance\n                info[\"similarity\"] = 1.0 / (1.0 + distance)\n                restaurants.append(info)\n\n        logger.info(f\"Returning {len(restaurants)} results\")\n        return restaurants\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.__init__","title":"<code>__init__(db_path=Path('data/restaurants_info/restaurants.db'), image_dir=Path('data/images/sample_images'), faiss_index_path=Path('data/embeddings/vibecheck_index.faiss'), meta_ids_path=Path('data/restaurants_info/meta_ids.npy'))</code>","text":"<p>Initialize with new data paths.</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def __init__(\n    self,\n    db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n    image_dir: Path = Path(\"data/images/sample_images\"),\n    faiss_index_path: Path = Path(\"data/embeddings/vibecheck_index.faiss\"),\n    meta_ids_path: Path = Path(\"data/restaurants_info/meta_ids.npy\"),\n):\n    \"\"\"Initialize with new data paths.\"\"\"\n    logger.info(\"Initializing VibeCheckRecommender\")\n    logger.debug(f\"Database path: {db_path}\")\n    logger.debug(f\"Image directory: {image_dir}\")\n    logger.debug(f\"FAISS index: {faiss_index_path}\")\n    logger.debug(f\"Meta IDs: {meta_ids_path}\")\n\n    self.db = RestaurantDatabase(db_path)\n    self.db_path = db_path  # Store for get_restaurant_info\n    self.image_dir = Path(image_dir)\n\n    # Load models\n    logger.info(\"Loading models...\")\n    self.text_model = ModelCache.get_text_model()\n    self.clip_model, self.clip_preprocess = ModelCache.get_clip_model()\n    self.device = ModelCache.get_device()\n\n    # Load search index\n    logger.info(\"Loading FAISS index...\")\n    try:\n        self.index = faiss.read_index(str(faiss_index_path))\n        self.meta_ids = np.load(str(meta_ids_path))\n        logger.info(f\"Loaded index with {len(self.meta_ids)} entries\")\n    except Exception as e:\n        logger.error(f\"Failed to load index: {e}\")\n        raise\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.encode_image","title":"<code>encode_image(image)</code>","text":"<p>Encode image into CLIP embedding vector.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>PIL Image of desired aesthetic.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized embedding vector of shape (512,).</p> Example <p>from PIL import Image recommender = VibeCheckRecommender() img = Image.open(\"restaurant.jpg\") vector = recommender.encode_image(img) vector.shape (512,)</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def encode_image(self, image: Image.Image) -&gt; np.ndarray:\n    \"\"\"\n    Encode image into CLIP embedding vector.\n\n    Args:\n        image: PIL Image of desired aesthetic.\n\n    Returns:\n        Normalized embedding vector of shape (512,).\n\n    Example:\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; img = Image.open(\"restaurant.jpg\")\n        &gt;&gt;&gt; vector = recommender.encode_image(img)\n        &gt;&gt;&gt; vector.shape\n        (512,)\n    \"\"\"\n    logger.debug(\"Encoding image...\")\n    img_tensor = self.clip_preprocess(image).unsqueeze(0).to(self.device)\n\n    with torch.no_grad():\n        img_vec = self.clip_model.encode_image(img_tensor)\n\n    img_vec /= img_vec.norm(dim=-1, keepdim=True)\n    return img_vec.cpu().numpy()[0]\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.encode_query","title":"<code>encode_query(text=None, image=None)</code>","text":"<p>Encode a multimodal query (text and/or image) into a combined embedding.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Optional text description of desired vibe.</p> <code>None</code> <code>image</code> <code>Image | None</code> <p>Optional PIL Image of desired aesthetic.</p> <code>None</code> <p>Returns:</p> Type Description <code>ndarray</code> <p>Combined embedding vector of shape (896,) = (384 text + 512 image).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If both text and image are None.</p> Example <p>recommender = VibeCheckRecommender()</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def encode_query(\n    self, text: str | None = None, image: Image.Image | None = None\n) -&gt; np.ndarray:\n    \"\"\"\n    Encode a multimodal query (text and/or image) into a combined embedding.\n\n    Args:\n        text: Optional text description of desired vibe.\n        image: Optional PIL Image of desired aesthetic.\n\n    Returns:\n        Combined embedding vector of shape (896,) = (384 text + 512 image).\n\n    Raises:\n        ValueError: If both text and image are None.\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; # Text only\n        &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\")\n        &gt;&gt;&gt; # Image only\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n        &gt;&gt;&gt; vec = recommender.encode_query(image=img)\n        &gt;&gt;&gt; # Both\n        &gt;&gt;&gt; vec = recommender.encode_query(text=\"cozy cafe\", image=img)\n    \"\"\"\n    if text is None and image is None:\n        logger.error(\"encode_query called with no text or image\")\n        raise ValueError(\"Must provide either text or image query\")\n\n    logger.info(f\"Encoding query - text: {bool(text)}, image: {bool(image)}\")\n\n    # Encode text (or use zeros if not provided)\n    text_vec = self.encode_text(text) if text else np.zeros((384,))\n\n    # Encode image (or use zeros if not provided)\n    image_vec = self.encode_image(image) if image else np.zeros((512,))\n\n    # Concatenate into single vector\n    combined = np.concatenate([text_vec, image_vec]).astype(\"float32\")\n    return combined[None, :]  # Add batch dimension\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.encode_query--text-only","title":"Text only","text":"<p>vec = recommender.encode_query(text=\"cozy cafe\")</p>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.encode_query--image-only","title":"Image only","text":"<p>from PIL import Image img = Image.open(\"cafe.jpg\") vec = recommender.encode_query(image=img)</p>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.encode_query--both","title":"Both","text":"<p>vec = recommender.encode_query(text=\"cozy cafe\", image=img)</p>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.encode_text","title":"<code>encode_text(text)</code>","text":"<p>Encode text query into embedding vector.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Text description of desired vibe.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Normalized embedding vector of shape (384,).</p> Example <p>recommender = VibeCheckRecommender() vector = recommender.encode_text(\"cozy cafe\") vector.shape (384,)</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def encode_text(self, text: str) -&gt; np.ndarray:\n    \"\"\"\n    Encode text query into embedding vector.\n\n    Args:\n        text: Text description of desired vibe.\n\n    Returns:\n        Normalized embedding vector of shape (384,).\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; vector = recommender.encode_text(\"cozy cafe\")\n        &gt;&gt;&gt; vector.shape\n        (384,)\n    \"\"\"\n    logger.debug(\n        f\"Encoding text: {text[:50]}...\"\n        if len(text) &gt; 50\n        else f\"Encoding text: {text}\"\n    )\n    return self.text_model.encode(\n        text, convert_to_numpy=True, normalize_embeddings=True\n    )\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.get_restaurant_info","title":"<code>get_restaurant_info(restaurant_id)</code>","text":"<p>Get detailed information about a restaurant from the database.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_id</code> <code>str</code> <p>Unique restaurant identifier.</p> required <p>Returns:</p> Name Type Description <code>dict[str, Any] | None</code> <p>Dictionary with restaurant details or None if not found.</p> <code>Keys</code> <code>dict[str, Any] | None</code> <p>'id', 'name', 'rating', 'address', 'image_url', 'image_path'</p> Example <p>recommender = VibeCheckRecommender() info = recommender.get_restaurant_info(\"some_id\") print(info['name']) print(info['rating'])</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def get_restaurant_info(self, restaurant_id: str) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Get detailed information about a restaurant from the database.\n\n    Args:\n        restaurant_id: Unique restaurant identifier.\n\n    Returns:\n        Dictionary with restaurant details or None if not found.\n        Keys: 'id', 'name', 'rating', 'address', 'image_url', 'image_path'\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; info = recommender.get_restaurant_info(\"some_id\")\n        &gt;&gt;&gt; print(info['name'])\n        &gt;&gt;&gt; print(info['rating'])\n    \"\"\"\n    logger.debug(f\"Fetching restaurant info: {restaurant_id}\")\n    try:\n        with sqlite3.connect(self.db_path) as conn:\n            row = conn.execute(\n                \"SELECT name, rating, address, image_url FROM restaurants WHERE id=?\",\n                (restaurant_id,),\n            ).fetchone()\n\n        if not row:\n            logger.debug(f\"Restaurant not found: {restaurant_id}\")\n            return None\n\n        name, rating, address, image_url = row\n        image_path = self.image_dir / f\"{restaurant_id}.jpg\"\n\n        logger.debug(f\"Found restaurant: {name}\")\n        return {\n            \"id\": restaurant_id,\n            \"name\": name,\n            \"rating\": rating,\n            \"address\": address,\n            \"image_url\": image_url,\n            \"image_path\": str(image_path) if image_path.exists() else None,\n        }\n\n    except Exception as e:\n        logger.error(f\"Error fetching restaurant {restaurant_id}: {e}\")\n        return None\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.search","title":"<code>search(query_vector, top_k=5)</code>","text":"<p>Search the FAISS index for similar restaurants.</p> <p>Parameters:</p> Name Type Description Default <code>query_vector</code> <code>ndarray</code> <p>Query embedding vector of shape (1, 896).</p> required <code>top_k</code> <code>int</code> <p>Number of top results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[tuple[str, float]]</code> <p>List of (restaurant_id, distance) tuples.</p> Example <p>recommender = VibeCheckRecommender() query_vec = recommender.encode_query(text=\"cozy cafe\") results = recommender.search(query_vec, top_k=5) for rid, distance in results: ...     print(f\"Restaurant {rid}: distance={distance:.4f}\")</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search(\n    self, query_vector: np.ndarray, top_k: int = 5\n) -&gt; list[tuple[str, float]]:\n    \"\"\"\n    Search the FAISS index for similar restaurants.\n\n    Args:\n        query_vector: Query embedding vector of shape (1, 896).\n        top_k: Number of top results to return.\n\n    Returns:\n        List of (restaurant_id, distance) tuples.\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; query_vec = recommender.encode_query(text=\"cozy cafe\")\n        &gt;&gt;&gt; results = recommender.search(query_vec, top_k=5)\n        &gt;&gt;&gt; for rid, distance in results:\n        ...     print(f\"Restaurant {rid}: distance={distance:.4f}\")\n    \"\"\"\n    logger.debug(f\"Searching index for top {top_k} results\")\n    distances, indices = self.index.search(query_vector, top_k)\n\n    results = []\n    for idx, distance in zip(indices[0], distances[0], strict=False):\n        restaurant_id = self.meta_ids[idx]\n        results.append((restaurant_id, float(distance)))\n\n    logger.debug(f\"Found {len(results)} results\")\n    return results\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.search_by_image","title":"<code>search_by_image(image, top_k=5)</code>","text":"<p>Search for restaurants matching an image aesthetic.</p> <p>Parameters:</p> Name Type Description Default <code>image</code> <code>Image</code> <p>PIL Image of desired aesthetic.</p> required <code>top_k</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of restaurant dictionaries with full information.</p> Example <p>from PIL import Image recommender = VibeCheckRecommender() img = Image.open(\"ideal_restaurant.jpg\") results = recommender.search_by_image(img, top_k=3) for resto in results: ...     print(resto['name'])</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search_by_image(\n    self, image: Image.Image, top_k: int = 5\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Search for restaurants matching an image aesthetic.\n\n    Args:\n        image: PIL Image of desired aesthetic.\n        top_k: Number of results to return.\n\n    Returns:\n        List of restaurant dictionaries with full information.\n\n    Example:\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; img = Image.open(\"ideal_restaurant.jpg\")\n        &gt;&gt;&gt; results = recommender.search_by_image(img, top_k=3)\n        &gt;&gt;&gt; for resto in results:\n        ...     print(resto['name'])\n    \"\"\"\n    logger.info(f\"Image search (top_k={top_k})\")\n\n    query_vec = self.encode_query(image=image)\n    search_results = self.search(query_vec, top_k=top_k)\n\n    restaurants = []\n    for restaurant_id, distance in search_results:\n        info = self.get_restaurant_info(restaurant_id)\n        if info:\n            info[\"distance\"] = distance\n            info[\"similarity\"] = 1.0 / (1.0 + distance)\n            restaurants.append(info)\n\n    logger.info(f\"Returning {len(restaurants)} results\")\n    return restaurants\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.search_by_text","title":"<code>search_by_text(text, top_k=5)</code>","text":"<p>Search for restaurants matching a text description.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str</code> <p>Description of desired vibe (e.g., \"cozy cafe with plants\").</p> required <code>top_k</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of restaurant dictionaries with full information.</p> Example <p>recommender = VibeCheckRecommender() results = recommender.search_by_text(\"cozy cafe with plants\", top_k=3) for resto in results: ...     print(f\"{resto['name']}: {resto['rating']} stars\")</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search_by_text(self, text: str, top_k: int = 5) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Search for restaurants matching a text description.\n\n    Args:\n        text: Description of desired vibe (e.g., \"cozy cafe with plants\").\n        top_k: Number of results to return.\n\n    Returns:\n        List of restaurant dictionaries with full information.\n\n    Example:\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; results = recommender.search_by_text(\"cozy cafe with plants\", top_k=3)\n        &gt;&gt;&gt; for resto in results:\n        ...     print(f\"{resto['name']}: {resto['rating']} stars\")\n    \"\"\"\n    logger.info(\n        f\"Text search: '{text[:50]}...' (top_k={top_k})\"\n        if len(text) &gt; 50\n        else f\"Text search: '{text}' (top_k={top_k})\"\n    )\n\n    query_vec = self.encode_query(text=text)\n    search_results = self.search(query_vec, top_k=top_k)\n\n    restaurants = []\n    for restaurant_id, distance in search_results:\n        info = self.get_restaurant_info(restaurant_id)\n        if info:\n            info[\"distance\"] = distance\n            info[\"similarity\"] = 1.0 / (\n                1.0 + distance\n            )  # Convert distance to similarity\n            restaurants.append(info)\n\n    logger.info(f\"Returning {len(restaurants)} results\")\n    return restaurants\n</code></pre>"},{"location":"reference/vibecheck/recommender/#vibecheck.recommender.VibeCheckRecommender.search_multimodal","title":"<code>search_multimodal(text=None, image=None, top_k=5)</code>","text":"<p>Search using both text and image simultaneously.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Optional text description.</p> <code>None</code> <code>image</code> <code>Image | None</code> <p>Optional PIL Image.</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Number of results to return.</p> <code>5</code> <p>Returns:</p> Type Description <code>list[dict[str, Any]]</code> <p>List of restaurant dictionaries with full information.</p> Example <p>from PIL import Image recommender = VibeCheckRecommender() img = Image.open(\"cafe.jpg\") results = recommender.search_multimodal( ...     text=\"cozy atmosphere\", ...     image=img, ...     top_k=5 ... )</p> Source code in <code>src/vibecheck/recommender.py</code> <pre><code>def search_multimodal(\n    self, text: str | None = None, image: Image.Image | None = None, top_k: int = 5\n) -&gt; list[dict[str, Any]]:\n    \"\"\"\n    Search using both text and image simultaneously.\n\n    Args:\n        text: Optional text description.\n        image: Optional PIL Image.\n        top_k: Number of results to return.\n\n    Returns:\n        List of restaurant dictionaries with full information.\n\n    Example:\n        &gt;&gt;&gt; from PIL import Image\n        &gt;&gt;&gt; recommender = VibeCheckRecommender()\n        &gt;&gt;&gt; img = Image.open(\"cafe.jpg\")\n        &gt;&gt;&gt; results = recommender.search_multimodal(\n        ...     text=\"cozy atmosphere\",\n        ...     image=img,\n        ...     top_k=5\n        ... )\n    \"\"\"\n    logger.info(\n        f\"Multimodal search (text={bool(text)}, image={bool(image)}, top_k={top_k})\"\n    )\n\n    query_vec = self.encode_query(text=text, image=image)\n    search_results = self.search(query_vec, top_k=top_k)\n\n    restaurants = []\n    for restaurant_id, distance in search_results:\n        info = self.get_restaurant_info(restaurant_id)\n        if info:\n            info[\"distance\"] = distance\n            info[\"similarity\"] = 1.0 / (1.0 + distance)\n            restaurants.append(info)\n\n    logger.info(f\"Returning {len(restaurants)} results\")\n    return restaurants\n</code></pre>"},{"location":"reference/vibecheck/utils/","title":"utils","text":""},{"location":"reference/vibecheck/utils/#vibecheck.utils","title":"<code>vibecheck.utils</code>","text":"<p>Utility functions for VibeCheck.</p>"},{"location":"reference/vibecheck/utils/#vibecheck.utils.hello_vibecheck","title":"<code>hello_vibecheck()</code>","text":"<p>Return a greeting message.</p> <p>Returns:</p> Type Description <code>str</code> <p>A welcome message string.</p> Example <p>hello_vibecheck() 'Welcome to VibeCheck!'</p> Source code in <code>src/vibecheck/utils.py</code> <pre><code>def hello_vibecheck() -&gt; str:\n    \"\"\"\n    Return a greeting message.\n\n    Returns:\n        A welcome message string.\n\n    Example:\n        &gt;&gt;&gt; hello_vibecheck()\n        'Welcome to VibeCheck!'\n    \"\"\"\n    return \"Welcome to VibeCheck!\"\n</code></pre>"},{"location":"reference/vibecheck/utils/#vibecheck.utils.validate_restaurant_name","title":"<code>validate_restaurant_name(name)</code>","text":"<p>Validate a restaurant name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The restaurant name to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the name is valid, False otherwise.</p> Example <p>validate_restaurant_name(\"Joe's Pizza\") True validate_restaurant_name(\"\") False</p> Source code in <code>src/vibecheck/utils.py</code> <pre><code>def validate_restaurant_name(name: str) -&gt; bool:\n    \"\"\"\n    Validate a restaurant name.\n\n    Args:\n        name: The restaurant name to validate.\n\n    Returns:\n        True if the name is valid, False otherwise.\n\n    Example:\n        &gt;&gt;&gt; validate_restaurant_name(\"Joe's Pizza\")\n        True\n        &gt;&gt;&gt; validate_restaurant_name(\"\")\n        False\n    \"\"\"\n    return bool(name and name.strip())\n</code></pre>"},{"location":"reference/vibecheck/analysis/","title":"analysis","text":""},{"location":"reference/vibecheck/analysis/#vibecheck.analysis","title":"<code>vibecheck.analysis</code>","text":""},{"location":"reference/vibecheck/analysis/vibe_mapper/","title":"vibe_mapper","text":""},{"location":"reference/vibecheck/analysis/vibe_mapper/#vibecheck.analysis.vibe_mapper","title":"<code>vibecheck.analysis.vibe_mapper</code>","text":"<p>UMAP + HDBSCAN clustering for vibe map visualization.</p>"},{"location":"reference/vibecheck/analysis/vibe_mapper/#vibecheck.analysis.vibe_mapper.VibeMapper","title":"<code>VibeMapper</code>","text":"<p>Create 2D visualization of restaurant vibes using UMAP + HDBSCAN.</p> Source code in <code>src/vibecheck/analysis/vibe_mapper.py</code> <pre><code>class VibeMapper:\n    \"\"\"\n    Create 2D visualization of restaurant vibes using UMAP + HDBSCAN.\n    \"\"\"\n\n    def __init__(\n        self,\n        embeddings_path: Path = Path(\"data/embeddings/vibe_embeddings.npy\"),\n        meta_ids_path: Path = Path(\"data/restaurants_info/meta_ids.npy\"),\n        db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n        use_mlflow: bool = True,\n    ):\n        \"\"\"Initialize mapper with embeddings and metadata.\"\"\"\n        logger.info(\"Initializing VibeMapper\")\n\n        logger.debug(f\"Loading embeddings from: {embeddings_path}\")\n        self.embeddings = np.load(embeddings_path)\n        logger.info(f\"Loaded embeddings: shape={self.embeddings.shape}\")\n\n        logger.debug(f\"Loading meta_ids from: {meta_ids_path}\")\n        self.meta_ids = np.load(meta_ids_path)\n        logger.info(f\"Loaded {len(self.meta_ids)} restaurant IDs\")\n\n        self.db = RestaurantDatabase(db_path)\n        self.use_mlflow = use_mlflow\n\n    def create_map(\n        self,\n        n_neighbors: int = 10,\n        min_dist: float = 0.05,\n        min_cluster_size: int = 5,\n        run_name: str | None = None,\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Create 2D vibe map with clusters.\n\n        Args:\n            n_neighbors: UMAP n_neighbors parameter.\n            min_dist: UMAP min_dist parameter.\n            min_cluster_size: HDBSCAN min_cluster_size parameter.\n            run_name: Optional name for the MLFlow run.\n\n        Returns:\n            DataFrame with columns: id, x, y, cluster, name, rating, categories.\n        \"\"\"\n        logger.info(\"Creating vibe map\")\n        logger.debug(f\"UMAP params: n_neighbors={n_neighbors}, min_dist={min_dist}\")\n        logger.debug(f\"HDBSCAN params: min_cluster_size={min_cluster_size}\")\n\n        # Start MLFlow run if enabled\n        if self.use_mlflow:\n            experiment_id = MLFlowConfig.get_or_create_experiment(\n                MLFlowConfig.VIBE_MAPPING_EXPERIMENT\n            )\n            mlflow.start_run(experiment_id=experiment_id, run_name=run_name)\n\n            # Log parameters\n            mlflow.log_param(\"n_neighbors\", n_neighbors)\n            mlflow.log_param(\"min_dist\", min_dist)\n            mlflow.log_param(\"min_cluster_size\", min_cluster_size)\n            mlflow.log_param(\"umap_metric\", \"cosine\")\n            mlflow.log_param(\"hdbscan_metric\", \"euclidean\")\n            mlflow.log_param(\"hdbscan_min_samples\", 2)\n            mlflow.log_param(\"num_restaurants\", len(self.embeddings))\n            mlflow.log_param(\"embedding_dim\", self.embeddings.shape[1])\n\n        try:\n            # UMAP projection\n            logger.info(\"Running UMAP projection...\")\n            reducer = umap.UMAP(\n                n_neighbors=n_neighbors,\n                min_dist=min_dist,\n                metric=\"cosine\",\n                random_state=42,\n            )\n            embedding_2d = reducer.fit_transform(self.embeddings)\n            logger.info(\"UMAP projection complete\")\n\n            # HDBSCAN clustering\n            logger.info(\"Running HDBSCAN clustering...\")\n            clusterer = hdbscan.HDBSCAN(\n                min_cluster_size=min_cluster_size, min_samples=2, metric=\"euclidean\"\n            )\n            labels = clusterer.fit_predict(embedding_2d)\n            n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n            n_noise = np.sum(labels == -1)\n            logger.info(f\"Found {n_clusters} clusters\")\n\n            # Get metadata\n            logger.info(\"Fetching restaurant metadata...\")\n            names, ratings, categories = [], [], []\n            for rid in tqdm(self.meta_ids, desc=\"Fetching metadata\"):\n                info = self.db.get_restaurant(rid)\n                if info:\n                    names.append(info[\"name\"])\n                    ratings.append(info[\"rating\"])\n                    categories.append(info[\"categories\"])\n                else:\n                    names.append(\"Unknown\")\n                    ratings.append(None)\n                    categories.append(\"\")\n\n            # Create DataFrame\n            df = pd.DataFrame(\n                {\n                    \"id\": self.meta_ids,\n                    \"x\": embedding_2d[:, 0],\n                    \"y\": embedding_2d[:, 1],\n                    \"cluster\": labels,\n                    \"name\": names,\n                    \"rating\": ratings,\n                    \"categories\": categories,\n                }\n            )\n\n            logger.info(f\"Vibe map created: {len(df)} points, {n_clusters} clusters\")\n\n            # Log metrics to MLFlow\n            if self.use_mlflow:\n                mlflow.log_metric(\"num_clusters\", n_clusters)\n                mlflow.log_metric(\"noise_points\", n_noise)\n                mlflow.log_metric(\"clustered_points\", len(df) - n_noise)\n                mlflow.log_metric(\n                    \"cluster_ratio\",\n                    (len(df) - n_noise) / len(df) if len(df) &gt; 0 else 0,\n                )\n\n                # Cluster size statistics\n                cluster_sizes = df[df[\"cluster\"] != -1].groupby(\"cluster\").size()\n                if len(cluster_sizes) &gt; 0:\n                    mlflow.log_metric(\"avg_cluster_size\", float(cluster_sizes.mean()))\n                    mlflow.log_metric(\"max_cluster_size\", int(cluster_sizes.max()))\n                    mlflow.log_metric(\"min_cluster_size\", int(cluster_sizes.min()))\n                    mlflow.log_metric(\"cluster_size_std\", float(cluster_sizes.std()))\n\n                # Log cluster probabilities if available\n                if hasattr(clusterer, \"probabilities_\"):\n                    mlflow.log_metric(\n                        \"avg_cluster_probability\",\n                        float(np.mean(clusterer.probabilities_)),\n                    )\n                    mlflow.log_metric(\n                        \"min_cluster_probability\",\n                        float(np.min(clusterer.probabilities_)),\n                    )\n\n                logger.info(\"Metrics logged to MLFlow\")\n\n        finally:\n            if self.use_mlflow:\n                mlflow.end_run()\n\n        return df\n</code></pre>"},{"location":"reference/vibecheck/analysis/vibe_mapper/#vibecheck.analysis.vibe_mapper.VibeMapper.__init__","title":"<code>__init__(embeddings_path=Path('data/embeddings/vibe_embeddings.npy'), meta_ids_path=Path('data/restaurants_info/meta_ids.npy'), db_path=Path('data/restaurants_info/restaurants.db'), use_mlflow=True)</code>","text":"<p>Initialize mapper with embeddings and metadata.</p> Source code in <code>src/vibecheck/analysis/vibe_mapper.py</code> <pre><code>def __init__(\n    self,\n    embeddings_path: Path = Path(\"data/embeddings/vibe_embeddings.npy\"),\n    meta_ids_path: Path = Path(\"data/restaurants_info/meta_ids.npy\"),\n    db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n    use_mlflow: bool = True,\n):\n    \"\"\"Initialize mapper with embeddings and metadata.\"\"\"\n    logger.info(\"Initializing VibeMapper\")\n\n    logger.debug(f\"Loading embeddings from: {embeddings_path}\")\n    self.embeddings = np.load(embeddings_path)\n    logger.info(f\"Loaded embeddings: shape={self.embeddings.shape}\")\n\n    logger.debug(f\"Loading meta_ids from: {meta_ids_path}\")\n    self.meta_ids = np.load(meta_ids_path)\n    logger.info(f\"Loaded {len(self.meta_ids)} restaurant IDs\")\n\n    self.db = RestaurantDatabase(db_path)\n    self.use_mlflow = use_mlflow\n</code></pre>"},{"location":"reference/vibecheck/analysis/vibe_mapper/#vibecheck.analysis.vibe_mapper.VibeMapper.create_map","title":"<code>create_map(n_neighbors=10, min_dist=0.05, min_cluster_size=5, run_name=None)</code>","text":"<p>Create 2D vibe map with clusters.</p> <p>Parameters:</p> Name Type Description Default <code>n_neighbors</code> <code>int</code> <p>UMAP n_neighbors parameter.</p> <code>10</code> <code>min_dist</code> <code>float</code> <p>UMAP min_dist parameter.</p> <code>0.05</code> <code>min_cluster_size</code> <code>int</code> <p>HDBSCAN min_cluster_size parameter.</p> <code>5</code> <code>run_name</code> <code>str | None</code> <p>Optional name for the MLFlow run.</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with columns: id, x, y, cluster, name, rating, categories.</p> Source code in <code>src/vibecheck/analysis/vibe_mapper.py</code> <pre><code>def create_map(\n    self,\n    n_neighbors: int = 10,\n    min_dist: float = 0.05,\n    min_cluster_size: int = 5,\n    run_name: str | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Create 2D vibe map with clusters.\n\n    Args:\n        n_neighbors: UMAP n_neighbors parameter.\n        min_dist: UMAP min_dist parameter.\n        min_cluster_size: HDBSCAN min_cluster_size parameter.\n        run_name: Optional name for the MLFlow run.\n\n    Returns:\n        DataFrame with columns: id, x, y, cluster, name, rating, categories.\n    \"\"\"\n    logger.info(\"Creating vibe map\")\n    logger.debug(f\"UMAP params: n_neighbors={n_neighbors}, min_dist={min_dist}\")\n    logger.debug(f\"HDBSCAN params: min_cluster_size={min_cluster_size}\")\n\n    # Start MLFlow run if enabled\n    if self.use_mlflow:\n        experiment_id = MLFlowConfig.get_or_create_experiment(\n            MLFlowConfig.VIBE_MAPPING_EXPERIMENT\n        )\n        mlflow.start_run(experiment_id=experiment_id, run_name=run_name)\n\n        # Log parameters\n        mlflow.log_param(\"n_neighbors\", n_neighbors)\n        mlflow.log_param(\"min_dist\", min_dist)\n        mlflow.log_param(\"min_cluster_size\", min_cluster_size)\n        mlflow.log_param(\"umap_metric\", \"cosine\")\n        mlflow.log_param(\"hdbscan_metric\", \"euclidean\")\n        mlflow.log_param(\"hdbscan_min_samples\", 2)\n        mlflow.log_param(\"num_restaurants\", len(self.embeddings))\n        mlflow.log_param(\"embedding_dim\", self.embeddings.shape[1])\n\n    try:\n        # UMAP projection\n        logger.info(\"Running UMAP projection...\")\n        reducer = umap.UMAP(\n            n_neighbors=n_neighbors,\n            min_dist=min_dist,\n            metric=\"cosine\",\n            random_state=42,\n        )\n        embedding_2d = reducer.fit_transform(self.embeddings)\n        logger.info(\"UMAP projection complete\")\n\n        # HDBSCAN clustering\n        logger.info(\"Running HDBSCAN clustering...\")\n        clusterer = hdbscan.HDBSCAN(\n            min_cluster_size=min_cluster_size, min_samples=2, metric=\"euclidean\"\n        )\n        labels = clusterer.fit_predict(embedding_2d)\n        n_clusters = len(set(labels)) - (1 if -1 in labels else 0)\n        n_noise = np.sum(labels == -1)\n        logger.info(f\"Found {n_clusters} clusters\")\n\n        # Get metadata\n        logger.info(\"Fetching restaurant metadata...\")\n        names, ratings, categories = [], [], []\n        for rid in tqdm(self.meta_ids, desc=\"Fetching metadata\"):\n            info = self.db.get_restaurant(rid)\n            if info:\n                names.append(info[\"name\"])\n                ratings.append(info[\"rating\"])\n                categories.append(info[\"categories\"])\n            else:\n                names.append(\"Unknown\")\n                ratings.append(None)\n                categories.append(\"\")\n\n        # Create DataFrame\n        df = pd.DataFrame(\n            {\n                \"id\": self.meta_ids,\n                \"x\": embedding_2d[:, 0],\n                \"y\": embedding_2d[:, 1],\n                \"cluster\": labels,\n                \"name\": names,\n                \"rating\": ratings,\n                \"categories\": categories,\n            }\n        )\n\n        logger.info(f\"Vibe map created: {len(df)} points, {n_clusters} clusters\")\n\n        # Log metrics to MLFlow\n        if self.use_mlflow:\n            mlflow.log_metric(\"num_clusters\", n_clusters)\n            mlflow.log_metric(\"noise_points\", n_noise)\n            mlflow.log_metric(\"clustered_points\", len(df) - n_noise)\n            mlflow.log_metric(\n                \"cluster_ratio\",\n                (len(df) - n_noise) / len(df) if len(df) &gt; 0 else 0,\n            )\n\n            # Cluster size statistics\n            cluster_sizes = df[df[\"cluster\"] != -1].groupby(\"cluster\").size()\n            if len(cluster_sizes) &gt; 0:\n                mlflow.log_metric(\"avg_cluster_size\", float(cluster_sizes.mean()))\n                mlflow.log_metric(\"max_cluster_size\", int(cluster_sizes.max()))\n                mlflow.log_metric(\"min_cluster_size\", int(cluster_sizes.min()))\n                mlflow.log_metric(\"cluster_size_std\", float(cluster_sizes.std()))\n\n            # Log cluster probabilities if available\n            if hasattr(clusterer, \"probabilities_\"):\n                mlflow.log_metric(\n                    \"avg_cluster_probability\",\n                    float(np.mean(clusterer.probabilities_)),\n                )\n                mlflow.log_metric(\n                    \"min_cluster_probability\",\n                    float(np.min(clusterer.probabilities_)),\n                )\n\n            logger.info(\"Metrics logged to MLFlow\")\n\n    finally:\n        if self.use_mlflow:\n            mlflow.end_run()\n\n    return df\n</code></pre>"},{"location":"reference/vibecheck/api/","title":"api","text":""},{"location":"reference/vibecheck/api/#vibecheck.api","title":"<code>vibecheck.api</code>","text":""},{"location":"reference/vibecheck/embeddings/","title":"embeddings","text":""},{"location":"reference/vibecheck/embeddings/#vibecheck.embeddings","title":"<code>vibecheck.embeddings</code>","text":""},{"location":"reference/vibecheck/embeddings/generator/","title":"generator","text":""},{"location":"reference/vibecheck/embeddings/generator/#vibecheck.embeddings.generator","title":"<code>vibecheck.embeddings.generator</code>","text":"<p>Generate embeddings for restaurants.</p>"},{"location":"reference/vibecheck/embeddings/generator/#vibecheck.embeddings.generator.EmbeddingGenerator","title":"<code>EmbeddingGenerator</code>","text":"<p>Generate embeddings for restaurant text and images.</p> Example <p>generator = EmbeddingGenerator() embeddings, ids = generator.generate_all() print(f\"Generated {len(embeddings)} embeddings\")</p> Source code in <code>src/vibecheck/embeddings/generator.py</code> <pre><code>class EmbeddingGenerator:\n    \"\"\"\n    Generate embeddings for restaurant text and images.\n\n    Example:\n        &gt;&gt;&gt; generator = EmbeddingGenerator()\n        &gt;&gt;&gt; embeddings, ids = generator.generate_all()\n        &gt;&gt;&gt; print(f\"Generated {len(embeddings)} embeddings\")\n    \"\"\"\n\n    def __init__(\n        self,\n        db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n        image_dir: Path = Path(\"data/images/sample_images\"),\n        use_mlflow: bool = True,\n    ):\n        \"\"\"Initialize generator with database and image directory.\"\"\"\n        logger.info(\"Initializing EmbeddingGenerator\")\n\n        self.db = RestaurantDatabase(db_path)\n        self.image_dir = Path(image_dir)\n        self.use_mlflow = use_mlflow\n\n        logger.debug(f\"Database path: {db_path}\")\n        logger.debug(f\"Image directory: {self.image_dir}\")\n\n        if not self.image_dir.exists():\n            logger.warning(f\"Image directory does not exist: {self.image_dir}\")\n\n        # Load models\n        logger.info(\"Loading embedding models...\")\n        self.text_model = ModelCache.get_text_model()\n        self.clip_model, self.clip_preprocess = ModelCache.get_clip_model()\n        self.device = ModelCache.get_device()\n        logger.info(\"Models loaded successfully\")\n\n    def generate_text_embedding(self, text: str) -&gt; np.ndarray:\n        \"\"\"Generate embedding for text.\"\"\"\n        logger.debug(f\"Generating text embedding for: {text[:50]}...\")\n        embedding: np.ndarray = self.text_model.encode(\n            text, convert_to_numpy=True, normalize_embeddings=True\n        )\n        return embedding\n\n    def generate_image_embedding(self, image_path: Path) -&gt; np.ndarray:\n        \"\"\"Generate CLIP embedding for image.\"\"\"\n        logger.debug(f\"Generating image embedding for: {image_path}\")\n\n        try:\n            image = (\n                self.clip_preprocess(Image.open(image_path))\n                .unsqueeze(0)\n                .to(self.device)\n            )\n\n            with torch.no_grad():\n                img_vec = self.clip_model.encode_image(image)\n\n            img_vec /= img_vec.norm(dim=-1, keepdim=True)\n            result: np.ndarray = img_vec.cpu().numpy()[0]\n            return result\n\n        except Exception as e:\n            logger.warning(f\"Error processing image {image_path}: {e}\")\n            return np.zeros((512,))\n\n    def generate_restaurant_embedding(\n        self, restaurant_id: str, text: str\n    ) -&gt; np.ndarray:\n        \"\"\"\n        Generate combined embedding for a restaurant.\n\n        Args:\n            restaurant_id: Restaurant ID for finding image.\n            text: Text to embed (review snippet or name).\n\n        Returns:\n            Combined embedding vector (384 text + 512 image = 896 dims).\n        \"\"\"\n        logger.debug(f\"Generating embedding for restaurant: {restaurant_id}\")\n\n        # Text embedding\n        text_vec = self.generate_text_embedding(text or \"\")\n\n        # Image embedding\n        img_path = self.image_dir / f\"{restaurant_id}.jpg\"\n        if img_path.exists():\n            img_vec = self.generate_image_embedding(img_path)\n        else:\n            logger.debug(f\"No image found for restaurant: {restaurant_id}\")\n            img_vec = np.zeros((512,))\n\n        # Combine\n        combined: np.ndarray = np.concatenate([text_vec, img_vec]).astype(\"float32\")\n        return combined\n\n    def generate_all(self, run_name: str | None = None) -&gt; tuple[np.ndarray, list[str]]:\n        \"\"\"\n        Generate embeddings for all restaurants in database.\n\n        Args:\n            run_name: Optional name for the MLFlow run.\n\n        Returns:\n            Tuple of (embeddings array, list of restaurant IDs).\n        \"\"\"\n        logger.info(\"Starting batch embedding generation\")\n\n        restaurants = self.db.get_all_restaurants()\n        logger.info(f\"Processing {len(restaurants)} restaurants\")\n\n        embeddings = []\n        meta_ids = []\n        errors = 0\n        images_found = 0\n\n        # Start MLFlow run if enabled\n        if self.use_mlflow:\n            experiment_id = MLFlowConfig.get_or_create_experiment(\n                MLFlowConfig.EMBEDDING_EXPERIMENT\n            )\n            mlflow.start_run(experiment_id=experiment_id, run_name=run_name)\n\n            # Log parameters\n            mlflow.log_param(\"total_restaurants\", len(restaurants))\n            mlflow.log_param(\"text_model\", \"all-MiniLM-L6-v2\")\n            mlflow.log_param(\"image_model\", \"CLIP-ViT-B/32\")\n            mlflow.log_param(\"text_embedding_dim\", 384)\n            mlflow.log_param(\"image_embedding_dim\", 512)\n            mlflow.log_param(\"combined_embedding_dim\", 896)\n            mlflow.log_param(\"device\", str(self.device))\n            mlflow.log_param(\"db_path\", str(self.db.db_path))\n            mlflow.log_param(\"image_dir\", str(self.image_dir))\n\n        try:\n            for i, resto in enumerate(tqdm(restaurants, desc=\"Generating embeddings\")):\n                try:\n                    text = resto[\"review_snippet\"] or resto[\"name\"] or \"\"\n                    embedding = self.generate_restaurant_embedding(resto[\"id\"], text)\n\n                    embeddings.append(embedding)\n                    meta_ids.append(resto[\"id\"])\n\n                    # Track if image was found\n                    img_path = self.image_dir / f\"{resto['id']}.jpg\"\n                    if img_path.exists():\n                        images_found += 1\n\n                    if (i + 1) % 50 == 0:\n                        logger.debug(\n                            f\"Processed {i + 1}/{len(restaurants)} restaurants\"\n                        )\n\n                except Exception as e:\n                    logger.error(f\"Error processing restaurant {resto['id']}: {e}\")\n                    errors += 1\n                    continue\n\n            logger.info(\n                f\"Embedding generation complete: {len(embeddings)} successful, {errors} errors\"\n            )\n\n            # Log metrics to MLFlow\n            if self.use_mlflow:\n                mlflow.log_metric(\"successful_embeddings\", len(embeddings))\n                mlflow.log_metric(\"failed_embeddings\", errors)\n                mlflow.log_metric(\"images_found\", images_found)\n                mlflow.log_metric(\"images_missing\", len(restaurants) - images_found)\n                mlflow.log_metric(\n                    \"success_rate\",\n                    len(embeddings) / len(restaurants) if restaurants else 0,\n                )\n                mlflow.log_metric(\n                    \"image_coverage\",\n                    images_found / len(restaurants) if restaurants else 0,\n                )\n\n                # Log embedding statistics\n                embeddings_array = np.vstack(embeddings).astype(\"float32\")\n                mlflow.log_metric(\"embedding_mean\", float(np.mean(embeddings_array)))\n                mlflow.log_metric(\"embedding_std\", float(np.std(embeddings_array)))\n                mlflow.log_metric(\"embedding_min\", float(np.min(embeddings_array)))\n                mlflow.log_metric(\"embedding_max\", float(np.max(embeddings_array)))\n\n                logger.info(\"Metrics logged to MLFlow\")\n\n        finally:\n            if self.use_mlflow:\n                mlflow.end_run()\n\n        return np.vstack(embeddings).astype(\"float32\"), meta_ids\n</code></pre>"},{"location":"reference/vibecheck/embeddings/generator/#vibecheck.embeddings.generator.EmbeddingGenerator.__init__","title":"<code>__init__(db_path=Path('data/restaurants_info/restaurants.db'), image_dir=Path('data/images/sample_images'), use_mlflow=True)</code>","text":"<p>Initialize generator with database and image directory.</p> Source code in <code>src/vibecheck/embeddings/generator.py</code> <pre><code>def __init__(\n    self,\n    db_path: Path = Path(\"data/restaurants_info/restaurants.db\"),\n    image_dir: Path = Path(\"data/images/sample_images\"),\n    use_mlflow: bool = True,\n):\n    \"\"\"Initialize generator with database and image directory.\"\"\"\n    logger.info(\"Initializing EmbeddingGenerator\")\n\n    self.db = RestaurantDatabase(db_path)\n    self.image_dir = Path(image_dir)\n    self.use_mlflow = use_mlflow\n\n    logger.debug(f\"Database path: {db_path}\")\n    logger.debug(f\"Image directory: {self.image_dir}\")\n\n    if not self.image_dir.exists():\n        logger.warning(f\"Image directory does not exist: {self.image_dir}\")\n\n    # Load models\n    logger.info(\"Loading embedding models...\")\n    self.text_model = ModelCache.get_text_model()\n    self.clip_model, self.clip_preprocess = ModelCache.get_clip_model()\n    self.device = ModelCache.get_device()\n    logger.info(\"Models loaded successfully\")\n</code></pre>"},{"location":"reference/vibecheck/embeddings/generator/#vibecheck.embeddings.generator.EmbeddingGenerator.generate_all","title":"<code>generate_all(run_name=None)</code>","text":"<p>Generate embeddings for all restaurants in database.</p> <p>Parameters:</p> Name Type Description Default <code>run_name</code> <code>str | None</code> <p>Optional name for the MLFlow run.</p> <code>None</code> <p>Returns:</p> Type Description <code>tuple[ndarray, list[str]]</code> <p>Tuple of (embeddings array, list of restaurant IDs).</p> Source code in <code>src/vibecheck/embeddings/generator.py</code> <pre><code>def generate_all(self, run_name: str | None = None) -&gt; tuple[np.ndarray, list[str]]:\n    \"\"\"\n    Generate embeddings for all restaurants in database.\n\n    Args:\n        run_name: Optional name for the MLFlow run.\n\n    Returns:\n        Tuple of (embeddings array, list of restaurant IDs).\n    \"\"\"\n    logger.info(\"Starting batch embedding generation\")\n\n    restaurants = self.db.get_all_restaurants()\n    logger.info(f\"Processing {len(restaurants)} restaurants\")\n\n    embeddings = []\n    meta_ids = []\n    errors = 0\n    images_found = 0\n\n    # Start MLFlow run if enabled\n    if self.use_mlflow:\n        experiment_id = MLFlowConfig.get_or_create_experiment(\n            MLFlowConfig.EMBEDDING_EXPERIMENT\n        )\n        mlflow.start_run(experiment_id=experiment_id, run_name=run_name)\n\n        # Log parameters\n        mlflow.log_param(\"total_restaurants\", len(restaurants))\n        mlflow.log_param(\"text_model\", \"all-MiniLM-L6-v2\")\n        mlflow.log_param(\"image_model\", \"CLIP-ViT-B/32\")\n        mlflow.log_param(\"text_embedding_dim\", 384)\n        mlflow.log_param(\"image_embedding_dim\", 512)\n        mlflow.log_param(\"combined_embedding_dim\", 896)\n        mlflow.log_param(\"device\", str(self.device))\n        mlflow.log_param(\"db_path\", str(self.db.db_path))\n        mlflow.log_param(\"image_dir\", str(self.image_dir))\n\n    try:\n        for i, resto in enumerate(tqdm(restaurants, desc=\"Generating embeddings\")):\n            try:\n                text = resto[\"review_snippet\"] or resto[\"name\"] or \"\"\n                embedding = self.generate_restaurant_embedding(resto[\"id\"], text)\n\n                embeddings.append(embedding)\n                meta_ids.append(resto[\"id\"])\n\n                # Track if image was found\n                img_path = self.image_dir / f\"{resto['id']}.jpg\"\n                if img_path.exists():\n                    images_found += 1\n\n                if (i + 1) % 50 == 0:\n                    logger.debug(\n                        f\"Processed {i + 1}/{len(restaurants)} restaurants\"\n                    )\n\n            except Exception as e:\n                logger.error(f\"Error processing restaurant {resto['id']}: {e}\")\n                errors += 1\n                continue\n\n        logger.info(\n            f\"Embedding generation complete: {len(embeddings)} successful, {errors} errors\"\n        )\n\n        # Log metrics to MLFlow\n        if self.use_mlflow:\n            mlflow.log_metric(\"successful_embeddings\", len(embeddings))\n            mlflow.log_metric(\"failed_embeddings\", errors)\n            mlflow.log_metric(\"images_found\", images_found)\n            mlflow.log_metric(\"images_missing\", len(restaurants) - images_found)\n            mlflow.log_metric(\n                \"success_rate\",\n                len(embeddings) / len(restaurants) if restaurants else 0,\n            )\n            mlflow.log_metric(\n                \"image_coverage\",\n                images_found / len(restaurants) if restaurants else 0,\n            )\n\n            # Log embedding statistics\n            embeddings_array = np.vstack(embeddings).astype(\"float32\")\n            mlflow.log_metric(\"embedding_mean\", float(np.mean(embeddings_array)))\n            mlflow.log_metric(\"embedding_std\", float(np.std(embeddings_array)))\n            mlflow.log_metric(\"embedding_min\", float(np.min(embeddings_array)))\n            mlflow.log_metric(\"embedding_max\", float(np.max(embeddings_array)))\n\n            logger.info(\"Metrics logged to MLFlow\")\n\n    finally:\n        if self.use_mlflow:\n            mlflow.end_run()\n\n    return np.vstack(embeddings).astype(\"float32\"), meta_ids\n</code></pre>"},{"location":"reference/vibecheck/embeddings/generator/#vibecheck.embeddings.generator.EmbeddingGenerator.generate_image_embedding","title":"<code>generate_image_embedding(image_path)</code>","text":"<p>Generate CLIP embedding for image.</p> Source code in <code>src/vibecheck/embeddings/generator.py</code> <pre><code>def generate_image_embedding(self, image_path: Path) -&gt; np.ndarray:\n    \"\"\"Generate CLIP embedding for image.\"\"\"\n    logger.debug(f\"Generating image embedding for: {image_path}\")\n\n    try:\n        image = (\n            self.clip_preprocess(Image.open(image_path))\n            .unsqueeze(0)\n            .to(self.device)\n        )\n\n        with torch.no_grad():\n            img_vec = self.clip_model.encode_image(image)\n\n        img_vec /= img_vec.norm(dim=-1, keepdim=True)\n        result: np.ndarray = img_vec.cpu().numpy()[0]\n        return result\n\n    except Exception as e:\n        logger.warning(f\"Error processing image {image_path}: {e}\")\n        return np.zeros((512,))\n</code></pre>"},{"location":"reference/vibecheck/embeddings/generator/#vibecheck.embeddings.generator.EmbeddingGenerator.generate_restaurant_embedding","title":"<code>generate_restaurant_embedding(restaurant_id, text)</code>","text":"<p>Generate combined embedding for a restaurant.</p> <p>Parameters:</p> Name Type Description Default <code>restaurant_id</code> <code>str</code> <p>Restaurant ID for finding image.</p> required <code>text</code> <code>str</code> <p>Text to embed (review snippet or name).</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Combined embedding vector (384 text + 512 image = 896 dims).</p> Source code in <code>src/vibecheck/embeddings/generator.py</code> <pre><code>def generate_restaurant_embedding(\n    self, restaurant_id: str, text: str\n) -&gt; np.ndarray:\n    \"\"\"\n    Generate combined embedding for a restaurant.\n\n    Args:\n        restaurant_id: Restaurant ID for finding image.\n        text: Text to embed (review snippet or name).\n\n    Returns:\n        Combined embedding vector (384 text + 512 image = 896 dims).\n    \"\"\"\n    logger.debug(f\"Generating embedding for restaurant: {restaurant_id}\")\n\n    # Text embedding\n    text_vec = self.generate_text_embedding(text or \"\")\n\n    # Image embedding\n    img_path = self.image_dir / f\"{restaurant_id}.jpg\"\n    if img_path.exists():\n        img_vec = self.generate_image_embedding(img_path)\n    else:\n        logger.debug(f\"No image found for restaurant: {restaurant_id}\")\n        img_vec = np.zeros((512,))\n\n    # Combine\n    combined: np.ndarray = np.concatenate([text_vec, img_vec]).astype(\"float32\")\n    return combined\n</code></pre>"},{"location":"reference/vibecheck/embeddings/generator/#vibecheck.embeddings.generator.EmbeddingGenerator.generate_text_embedding","title":"<code>generate_text_embedding(text)</code>","text":"<p>Generate embedding for text.</p> Source code in <code>src/vibecheck/embeddings/generator.py</code> <pre><code>def generate_text_embedding(self, text: str) -&gt; np.ndarray:\n    \"\"\"Generate embedding for text.\"\"\"\n    logger.debug(f\"Generating text embedding for: {text[:50]}...\")\n    embedding: np.ndarray = self.text_model.encode(\n        text, convert_to_numpy=True, normalize_embeddings=True\n    )\n    return embedding\n</code></pre>"},{"location":"reference/vibecheck/embeddings/models/","title":"models","text":""},{"location":"reference/vibecheck/embeddings/models/#vibecheck.embeddings.models","title":"<code>vibecheck.embeddings.models</code>","text":"<p>Model loading and caching for embeddings.</p>"},{"location":"reference/vibecheck/embeddings/models/#vibecheck.embeddings.models.ModelCache","title":"<code>ModelCache</code>","text":"<p>Cache for pre-trained models to avoid reloading.</p> Source code in <code>src/vibecheck/embeddings/models.py</code> <pre><code>class ModelCache:\n    \"\"\"Cache for pre-trained models to avoid reloading.\"\"\"\n\n    _text_model = None\n    _clip_model = None\n    _clip_preprocess = None\n    _device = None\n\n    @classmethod\n    def get_device(cls) -&gt; str:\n        \"\"\"Get computing device (cuda or cpu).\"\"\"\n        if cls._device is None:\n            cls._device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n            logger.info(f\"Using device: {cls._device}\")\n        return cls._device\n\n    @classmethod\n    def get_text_model(cls) -&gt; SentenceTransformer:\n        \"\"\"Get or load text embedding model.\"\"\"\n        if cls._text_model is None:\n            logger.info(\"Loading text model (all-MiniLM-L6-v2)...\")\n            try:\n                cls._text_model = SentenceTransformer(\n                    \"all-MiniLM-L6-v2\", device=cls.get_device()\n                )\n                logger.info(\"Text model loaded successfully\")\n            except Exception as e:\n                logger.error(f\"Failed to load text model: {e}\")\n                raise\n        return cls._text_model\n\n    @classmethod\n    def get_clip_model(cls) -&gt; tuple:\n        \"\"\"Get or load CLIP model and preprocessor.\"\"\"\n        if cls._clip_model is None:\n            logger.info(\"Loading CLIP model (ViT-B/32)...\")\n            try:\n                cls._clip_model, cls._clip_preprocess = clip.load(\n                    \"ViT-B/32\", device=cls.get_device()\n                )\n                logger.info(\"CLIP model loaded successfully\")\n            except Exception as e:\n                logger.error(f\"Failed to load CLIP model: {e}\")\n                raise\n        return cls._clip_model, cls._clip_preprocess\n\n    @classmethod\n    def clear_cache(cls):\n        \"\"\"Clear all cached models to free memory.\"\"\"\n        logger.info(\"Clearing model cache\")\n        cls._text_model = None\n        cls._clip_model = None\n        cls._clip_preprocess = None\n        cls._device = None\n        logger.debug(\"Model cache cleared\")\n</code></pre>"},{"location":"reference/vibecheck/embeddings/models/#vibecheck.embeddings.models.ModelCache.clear_cache","title":"<code>clear_cache()</code>  <code>classmethod</code>","text":"<p>Clear all cached models to free memory.</p> Source code in <code>src/vibecheck/embeddings/models.py</code> <pre><code>@classmethod\ndef clear_cache(cls):\n    \"\"\"Clear all cached models to free memory.\"\"\"\n    logger.info(\"Clearing model cache\")\n    cls._text_model = None\n    cls._clip_model = None\n    cls._clip_preprocess = None\n    cls._device = None\n    logger.debug(\"Model cache cleared\")\n</code></pre>"},{"location":"reference/vibecheck/embeddings/models/#vibecheck.embeddings.models.ModelCache.get_clip_model","title":"<code>get_clip_model()</code>  <code>classmethod</code>","text":"<p>Get or load CLIP model and preprocessor.</p> Source code in <code>src/vibecheck/embeddings/models.py</code> <pre><code>@classmethod\ndef get_clip_model(cls) -&gt; tuple:\n    \"\"\"Get or load CLIP model and preprocessor.\"\"\"\n    if cls._clip_model is None:\n        logger.info(\"Loading CLIP model (ViT-B/32)...\")\n        try:\n            cls._clip_model, cls._clip_preprocess = clip.load(\n                \"ViT-B/32\", device=cls.get_device()\n            )\n            logger.info(\"CLIP model loaded successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to load CLIP model: {e}\")\n            raise\n    return cls._clip_model, cls._clip_preprocess\n</code></pre>"},{"location":"reference/vibecheck/embeddings/models/#vibecheck.embeddings.models.ModelCache.get_device","title":"<code>get_device()</code>  <code>classmethod</code>","text":"<p>Get computing device (cuda or cpu).</p> Source code in <code>src/vibecheck/embeddings/models.py</code> <pre><code>@classmethod\ndef get_device(cls) -&gt; str:\n    \"\"\"Get computing device (cuda or cpu).\"\"\"\n    if cls._device is None:\n        cls._device = \"cuda\" if torch.cuda.is_available() else \"cpu\"\n        logger.info(f\"Using device: {cls._device}\")\n    return cls._device\n</code></pre>"},{"location":"reference/vibecheck/embeddings/models/#vibecheck.embeddings.models.ModelCache.get_text_model","title":"<code>get_text_model()</code>  <code>classmethod</code>","text":"<p>Get or load text embedding model.</p> Source code in <code>src/vibecheck/embeddings/models.py</code> <pre><code>@classmethod\ndef get_text_model(cls) -&gt; SentenceTransformer:\n    \"\"\"Get or load text embedding model.\"\"\"\n    if cls._text_model is None:\n        logger.info(\"Loading text model (all-MiniLM-L6-v2)...\")\n        try:\n            cls._text_model = SentenceTransformer(\n                \"all-MiniLM-L6-v2\", device=cls.get_device()\n            )\n            logger.info(\"Text model loaded successfully\")\n        except Exception as e:\n            logger.error(f\"Failed to load text model: {e}\")\n            raise\n    return cls._text_model\n</code></pre>"},{"location":"reference/vibecheck/monitoring/","title":"monitoring","text":""},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring","title":"<code>vibecheck.monitoring</code>","text":"<p>Monitoring module for VibeCheck.</p>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.EvidentlyMonitor","title":"<code>EvidentlyMonitor</code>","text":"<p>Monitor recommendation system performance using Evidently.</p> <p>Tracks: - Embedding distribution drift - Recommendation quality metrics - Data quality issues - Performance over time</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>class EvidentlyMonitor:\n    \"\"\"\n    Monitor recommendation system performance using Evidently.\n\n    Tracks:\n    - Embedding distribution drift\n    - Recommendation quality metrics\n    - Data quality issues\n    - Performance over time\n    \"\"\"\n\n    def __init__(\n        self,\n        reports_dir: Path = Path(\"monitoring/reports\"),\n        tests_dir: Path = Path(\"monitoring/tests\"),\n    ):\n        \"\"\"Initialize Evidently monitor.\"\"\"\n        self.reports_dir = Path(reports_dir)\n        self.tests_dir = Path(tests_dir)\n\n        # Create directories\n        self.reports_dir.mkdir(parents=True, exist_ok=True)\n        self.tests_dir.mkdir(parents=True, exist_ok=True)\n\n        logger.info(\"Evidently monitor initialized\")\n        logger.info(f\"Reports directory: {self.reports_dir}\")\n        logger.info(f\"Tests directory: {self.tests_dir}\")\n\n    def create_embedding_drift_report(\n        self,\n        reference_embeddings: np.ndarray,\n        current_embeddings: np.ndarray,\n        reference_ids: list[str],\n        current_ids: list[str],\n        report_name: str | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Create a data drift report for embeddings.\n\n        Args:\n            reference_embeddings: Reference (baseline) embeddings\n            current_embeddings: Current embeddings to compare\n            reference_ids: IDs for reference embeddings\n            current_ids: IDs for current embeddings\n            report_name: Optional custom report name\n\n        Returns:\n            Path to the generated report\n        \"\"\"\n        logger.info(\"Creating embedding drift report\")\n\n        # Convert to DataFrames\n        ref_df = self._embeddings_to_dataframe(reference_embeddings, reference_ids)\n        curr_df = self._embeddings_to_dataframe(current_embeddings, current_ids)\n\n        # Create report\n        report = Report(\n            metrics=[\n                DataDriftPreset(),\n                DataQualityPreset(),\n            ]\n        )\n\n        report.run(reference_data=ref_df, current_data=curr_df)\n\n        # Save report\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        report_name = report_name or f\"embedding_drift_{timestamp}\"\n        report_path = self.reports_dir / f\"{report_name}.html\"\n\n        report.save_html(str(report_path))\n        logger.info(f\"Report saved to: {report_path}\")\n\n        # Save JSON summary\n        json_path = self.reports_dir / f\"{report_name}.json\"\n        report.save_json(str(json_path))\n\n        return str(report_path)\n\n    def create_recommendation_quality_report(\n        self,\n        recommendations_data: pd.DataFrame,\n        reference_data: pd.DataFrame | None = None,\n        report_name: str | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Create a report for recommendation quality metrics.\n\n        Args:\n            recommendations_data: DataFrame with recommendation results\n                Expected columns: query_id, restaurant_id, similarity_score, rank\n            reference_data: Optional reference data for comparison\n            report_name: Optional custom report name\n\n        Returns:\n            Path to the generated report\n        \"\"\"\n        logger.info(\"Creating recommendation quality report\")\n\n        if reference_data is not None:\n            report = Report(\n                metrics=[\n                    DataDriftPreset(),\n                    DataQualityPreset(),\n                ]\n            )\n            report.run(reference_data=reference_data, current_data=recommendations_data)\n        else:\n            report = Report(\n                metrics=[\n                    DataQualityPreset(),\n                ]\n            )\n            report.run(reference_data=None, current_data=recommendations_data)\n\n        # Save report\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        report_name = report_name or f\"recommendation_quality_{timestamp}\"\n        report_path = self.reports_dir / f\"{report_name}.html\"\n\n        report.save_html(str(report_path))\n        logger.info(f\"Report saved to: {report_path}\")\n\n        return str(report_path)\n\n    def run_data_quality_tests(\n        self,\n        data: pd.DataFrame,\n        test_name: str | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Run data quality tests on the provided data.\n\n        Args:\n            data: DataFrame to test\n            test_name: Optional custom test name\n\n        Returns:\n            Dictionary with test results\n        \"\"\"\n        logger.info(\"Running data quality tests\")\n\n        test_suite = TestSuite(\n            tests=[\n                DataQualityTestPreset(),\n            ]\n        )\n\n        test_suite.run(reference_data=None, current_data=data)\n\n        # Save test results\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        test_name = test_name or f\"data_quality_{timestamp}\"\n        test_path = self.tests_dir / f\"{test_name}.html\"\n\n        test_suite.save_html(str(test_path))\n        logger.info(f\"Test results saved to: {test_path}\")\n\n        # Get test results as dict\n        results: dict[str, Any] = test_suite.as_dict()\n\n        # Save JSON\n        json_path = self.tests_dir / f\"{test_name}.json\"\n        with open(json_path, \"w\") as f:\n            json.dump(results, f, indent=2)\n\n        return results\n\n    def run_drift_tests(\n        self,\n        reference_data: pd.DataFrame,\n        current_data: pd.DataFrame,\n        test_name: str | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Run data drift tests comparing reference and current data.\n\n        Args:\n            reference_data: Reference (baseline) data\n            current_data: Current data to test\n            test_name: Optional custom test name\n\n        Returns:\n            Dictionary with test results\n        \"\"\"\n        logger.info(\"Running data drift tests\")\n\n        test_suite = TestSuite(\n            tests=[\n                DataDriftTestPreset(),\n            ]\n        )\n\n        test_suite.run(reference_data=reference_data, current_data=current_data)\n\n        # Save test results\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        test_name = test_name or f\"data_drift_{timestamp}\"\n        test_path = self.tests_dir / f\"{test_name}.html\"\n\n        test_suite.save_html(str(test_path))\n        logger.info(f\"Test results saved to: {test_path}\")\n\n        # Get test results as dict\n        results: dict[str, Any] = test_suite.as_dict()\n\n        # Save JSON\n        json_path = self.tests_dir / f\"{test_name}.json\"\n        with open(json_path, \"w\") as f:\n            json.dump(results, f, indent=2)\n\n        return results\n\n    def _embeddings_to_dataframe(\n        self,\n        embeddings: np.ndarray,\n        ids: list[str],\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Convert embeddings array to DataFrame.\n\n        Args:\n            embeddings: Numpy array of embeddings\n            ids: List of IDs\n\n        Returns:\n            DataFrame with embeddings as columns\n        \"\"\"\n        # Create column names\n        n_dims = embeddings.shape[1]\n        columns = [f\"dim_{i}\" for i in range(n_dims)]\n\n        # Create DataFrame\n        df = pd.DataFrame(embeddings, columns=columns)\n        df.insert(0, \"id\", ids)\n\n        return df\n\n    def generate_monitoring_dashboard(\n        self,\n        embeddings: np.ndarray,\n        ids: list[str],\n        recommendations: pd.DataFrame,\n        dashboard_name: str | None = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"\n        Generate a comprehensive monitoring dashboard.\n\n        Args:\n            embeddings: Current embeddings\n            ids: Embedding IDs\n            recommendations: Recent recommendations data\n            dashboard_name: Optional custom dashboard name\n\n        Returns:\n            Dictionary with paths to generated reports\n        \"\"\"\n        logger.info(\"Generating monitoring dashboard\")\n\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        dashboard_name = dashboard_name or f\"dashboard_{timestamp}\"\n\n        # Convert embeddings to DataFrame\n        embeddings_df = self._embeddings_to_dataframe(embeddings, ids)\n\n        # Run data quality tests\n        self.run_data_quality_tests(\n            embeddings_df, test_name=f\"{dashboard_name}_embeddings_quality\"\n        )\n\n        # Create recommendation quality report\n        rec_report = self.create_recommendation_quality_report(\n            recommendations, report_name=f\"{dashboard_name}_recommendations\"\n        )\n\n        paths = {\n            \"embeddings_quality_test\": str(\n                self.tests_dir / f\"{dashboard_name}_embeddings_quality.html\"\n            ),\n            \"recommendations_report\": rec_report,\n        }\n\n        logger.info(f\"Dashboard generated with {len(paths)} reports\")\n        return paths\n</code></pre>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.EvidentlyMonitor.__init__","title":"<code>__init__(reports_dir=Path('monitoring/reports'), tests_dir=Path('monitoring/tests'))</code>","text":"<p>Initialize Evidently monitor.</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def __init__(\n    self,\n    reports_dir: Path = Path(\"monitoring/reports\"),\n    tests_dir: Path = Path(\"monitoring/tests\"),\n):\n    \"\"\"Initialize Evidently monitor.\"\"\"\n    self.reports_dir = Path(reports_dir)\n    self.tests_dir = Path(tests_dir)\n\n    # Create directories\n    self.reports_dir.mkdir(parents=True, exist_ok=True)\n    self.tests_dir.mkdir(parents=True, exist_ok=True)\n\n    logger.info(\"Evidently monitor initialized\")\n    logger.info(f\"Reports directory: {self.reports_dir}\")\n    logger.info(f\"Tests directory: {self.tests_dir}\")\n</code></pre>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.EvidentlyMonitor.create_embedding_drift_report","title":"<code>create_embedding_drift_report(reference_embeddings, current_embeddings, reference_ids, current_ids, report_name=None)</code>","text":"<p>Create a data drift report for embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>reference_embeddings</code> <code>ndarray</code> <p>Reference (baseline) embeddings</p> required <code>current_embeddings</code> <code>ndarray</code> <p>Current embeddings to compare</p> required <code>reference_ids</code> <code>list[str]</code> <p>IDs for reference embeddings</p> required <code>current_ids</code> <code>list[str]</code> <p>IDs for current embeddings</p> required <code>report_name</code> <code>str | None</code> <p>Optional custom report name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the generated report</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def create_embedding_drift_report(\n    self,\n    reference_embeddings: np.ndarray,\n    current_embeddings: np.ndarray,\n    reference_ids: list[str],\n    current_ids: list[str],\n    report_name: str | None = None,\n) -&gt; str:\n    \"\"\"\n    Create a data drift report for embeddings.\n\n    Args:\n        reference_embeddings: Reference (baseline) embeddings\n        current_embeddings: Current embeddings to compare\n        reference_ids: IDs for reference embeddings\n        current_ids: IDs for current embeddings\n        report_name: Optional custom report name\n\n    Returns:\n        Path to the generated report\n    \"\"\"\n    logger.info(\"Creating embedding drift report\")\n\n    # Convert to DataFrames\n    ref_df = self._embeddings_to_dataframe(reference_embeddings, reference_ids)\n    curr_df = self._embeddings_to_dataframe(current_embeddings, current_ids)\n\n    # Create report\n    report = Report(\n        metrics=[\n            DataDriftPreset(),\n            DataQualityPreset(),\n        ]\n    )\n\n    report.run(reference_data=ref_df, current_data=curr_df)\n\n    # Save report\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    report_name = report_name or f\"embedding_drift_{timestamp}\"\n    report_path = self.reports_dir / f\"{report_name}.html\"\n\n    report.save_html(str(report_path))\n    logger.info(f\"Report saved to: {report_path}\")\n\n    # Save JSON summary\n    json_path = self.reports_dir / f\"{report_name}.json\"\n    report.save_json(str(json_path))\n\n    return str(report_path)\n</code></pre>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.EvidentlyMonitor.create_recommendation_quality_report","title":"<code>create_recommendation_quality_report(recommendations_data, reference_data=None, report_name=None)</code>","text":"<p>Create a report for recommendation quality metrics.</p> <p>Parameters:</p> Name Type Description Default <code>recommendations_data</code> <code>DataFrame</code> <p>DataFrame with recommendation results Expected columns: query_id, restaurant_id, similarity_score, rank</p> required <code>reference_data</code> <code>DataFrame | None</code> <p>Optional reference data for comparison</p> <code>None</code> <code>report_name</code> <code>str | None</code> <p>Optional custom report name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the generated report</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def create_recommendation_quality_report(\n    self,\n    recommendations_data: pd.DataFrame,\n    reference_data: pd.DataFrame | None = None,\n    report_name: str | None = None,\n) -&gt; str:\n    \"\"\"\n    Create a report for recommendation quality metrics.\n\n    Args:\n        recommendations_data: DataFrame with recommendation results\n            Expected columns: query_id, restaurant_id, similarity_score, rank\n        reference_data: Optional reference data for comparison\n        report_name: Optional custom report name\n\n    Returns:\n        Path to the generated report\n    \"\"\"\n    logger.info(\"Creating recommendation quality report\")\n\n    if reference_data is not None:\n        report = Report(\n            metrics=[\n                DataDriftPreset(),\n                DataQualityPreset(),\n            ]\n        )\n        report.run(reference_data=reference_data, current_data=recommendations_data)\n    else:\n        report = Report(\n            metrics=[\n                DataQualityPreset(),\n            ]\n        )\n        report.run(reference_data=None, current_data=recommendations_data)\n\n    # Save report\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    report_name = report_name or f\"recommendation_quality_{timestamp}\"\n    report_path = self.reports_dir / f\"{report_name}.html\"\n\n    report.save_html(str(report_path))\n    logger.info(f\"Report saved to: {report_path}\")\n\n    return str(report_path)\n</code></pre>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.EvidentlyMonitor.generate_monitoring_dashboard","title":"<code>generate_monitoring_dashboard(embeddings, ids, recommendations, dashboard_name=None)</code>","text":"<p>Generate a comprehensive monitoring dashboard.</p> <p>Parameters:</p> Name Type Description Default <code>embeddings</code> <code>ndarray</code> <p>Current embeddings</p> required <code>ids</code> <code>list[str]</code> <p>Embedding IDs</p> required <code>recommendations</code> <code>DataFrame</code> <p>Recent recommendations data</p> required <code>dashboard_name</code> <code>str | None</code> <p>Optional custom dashboard name</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary with paths to generated reports</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def generate_monitoring_dashboard(\n    self,\n    embeddings: np.ndarray,\n    ids: list[str],\n    recommendations: pd.DataFrame,\n    dashboard_name: str | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"\n    Generate a comprehensive monitoring dashboard.\n\n    Args:\n        embeddings: Current embeddings\n        ids: Embedding IDs\n        recommendations: Recent recommendations data\n        dashboard_name: Optional custom dashboard name\n\n    Returns:\n        Dictionary with paths to generated reports\n    \"\"\"\n    logger.info(\"Generating monitoring dashboard\")\n\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    dashboard_name = dashboard_name or f\"dashboard_{timestamp}\"\n\n    # Convert embeddings to DataFrame\n    embeddings_df = self._embeddings_to_dataframe(embeddings, ids)\n\n    # Run data quality tests\n    self.run_data_quality_tests(\n        embeddings_df, test_name=f\"{dashboard_name}_embeddings_quality\"\n    )\n\n    # Create recommendation quality report\n    rec_report = self.create_recommendation_quality_report(\n        recommendations, report_name=f\"{dashboard_name}_recommendations\"\n    )\n\n    paths = {\n        \"embeddings_quality_test\": str(\n            self.tests_dir / f\"{dashboard_name}_embeddings_quality.html\"\n        ),\n        \"recommendations_report\": rec_report,\n    }\n\n    logger.info(f\"Dashboard generated with {len(paths)} reports\")\n    return paths\n</code></pre>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.EvidentlyMonitor.run_data_quality_tests","title":"<code>run_data_quality_tests(data, test_name=None)</code>","text":"<p>Run data quality tests on the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame to test</p> required <code>test_name</code> <code>str | None</code> <p>Optional custom test name</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with test results</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def run_data_quality_tests(\n    self,\n    data: pd.DataFrame,\n    test_name: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Run data quality tests on the provided data.\n\n    Args:\n        data: DataFrame to test\n        test_name: Optional custom test name\n\n    Returns:\n        Dictionary with test results\n    \"\"\"\n    logger.info(\"Running data quality tests\")\n\n    test_suite = TestSuite(\n        tests=[\n            DataQualityTestPreset(),\n        ]\n    )\n\n    test_suite.run(reference_data=None, current_data=data)\n\n    # Save test results\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    test_name = test_name or f\"data_quality_{timestamp}\"\n    test_path = self.tests_dir / f\"{test_name}.html\"\n\n    test_suite.save_html(str(test_path))\n    logger.info(f\"Test results saved to: {test_path}\")\n\n    # Get test results as dict\n    results: dict[str, Any] = test_suite.as_dict()\n\n    # Save JSON\n    json_path = self.tests_dir / f\"{test_name}.json\"\n    with open(json_path, \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    return results\n</code></pre>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.EvidentlyMonitor.run_drift_tests","title":"<code>run_drift_tests(reference_data, current_data, test_name=None)</code>","text":"<p>Run data drift tests comparing reference and current data.</p> <p>Parameters:</p> Name Type Description Default <code>reference_data</code> <code>DataFrame</code> <p>Reference (baseline) data</p> required <code>current_data</code> <code>DataFrame</code> <p>Current data to test</p> required <code>test_name</code> <code>str | None</code> <p>Optional custom test name</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with test results</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def run_drift_tests(\n    self,\n    reference_data: pd.DataFrame,\n    current_data: pd.DataFrame,\n    test_name: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Run data drift tests comparing reference and current data.\n\n    Args:\n        reference_data: Reference (baseline) data\n        current_data: Current data to test\n        test_name: Optional custom test name\n\n    Returns:\n        Dictionary with test results\n    \"\"\"\n    logger.info(\"Running data drift tests\")\n\n    test_suite = TestSuite(\n        tests=[\n            DataDriftTestPreset(),\n        ]\n    )\n\n    test_suite.run(reference_data=reference_data, current_data=current_data)\n\n    # Save test results\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    test_name = test_name or f\"data_drift_{timestamp}\"\n    test_path = self.tests_dir / f\"{test_name}.html\"\n\n    test_suite.save_html(str(test_path))\n    logger.info(f\"Test results saved to: {test_path}\")\n\n    # Get test results as dict\n    results: dict[str, Any] = test_suite.as_dict()\n\n    # Save JSON\n    json_path = self.tests_dir / f\"{test_name}.json\"\n    with open(json_path, \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    return results\n</code></pre>"},{"location":"reference/vibecheck/monitoring/#vibecheck.monitoring.create_sample_recommendations_data","title":"<code>create_sample_recommendations_data(query_ids, restaurant_ids, similarity_scores)</code>","text":"<p>Helper function to create sample recommendations DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query_ids</code> <code>list[str]</code> <p>List of query IDs</p> required <code>restaurant_ids</code> <code>list[str]</code> <p>List of recommended restaurant IDs</p> required <code>similarity_scores</code> <code>list[float]</code> <p>List of similarity scores</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with recommendations data</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def create_sample_recommendations_data(\n    query_ids: list[str],\n    restaurant_ids: list[str],\n    similarity_scores: list[float],\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Helper function to create sample recommendations DataFrame.\n\n    Args:\n        query_ids: List of query IDs\n        restaurant_ids: List of recommended restaurant IDs\n        similarity_scores: List of similarity scores\n\n    Returns:\n        DataFrame with recommendations data\n    \"\"\"\n    return pd.DataFrame(\n        {\n            \"query_id\": query_ids,\n            \"restaurant_id\": restaurant_ids,\n            \"similarity_score\": similarity_scores,\n            \"timestamp\": datetime.now(),\n        }\n    )\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/","title":"evidently_monitor","text":""},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor","title":"<code>vibecheck.monitoring.evidently_monitor</code>","text":"<p>Evidently monitoring for VibeCheck recommendation system.</p>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.EvidentlyMonitor","title":"<code>EvidentlyMonitor</code>","text":"<p>Monitor recommendation system performance using Evidently.</p> <p>Tracks: - Embedding distribution drift - Recommendation quality metrics - Data quality issues - Performance over time</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>class EvidentlyMonitor:\n    \"\"\"\n    Monitor recommendation system performance using Evidently.\n\n    Tracks:\n    - Embedding distribution drift\n    - Recommendation quality metrics\n    - Data quality issues\n    - Performance over time\n    \"\"\"\n\n    def __init__(\n        self,\n        reports_dir: Path = Path(\"monitoring/reports\"),\n        tests_dir: Path = Path(\"monitoring/tests\"),\n    ):\n        \"\"\"Initialize Evidently monitor.\"\"\"\n        self.reports_dir = Path(reports_dir)\n        self.tests_dir = Path(tests_dir)\n\n        # Create directories\n        self.reports_dir.mkdir(parents=True, exist_ok=True)\n        self.tests_dir.mkdir(parents=True, exist_ok=True)\n\n        logger.info(\"Evidently monitor initialized\")\n        logger.info(f\"Reports directory: {self.reports_dir}\")\n        logger.info(f\"Tests directory: {self.tests_dir}\")\n\n    def create_embedding_drift_report(\n        self,\n        reference_embeddings: np.ndarray,\n        current_embeddings: np.ndarray,\n        reference_ids: list[str],\n        current_ids: list[str],\n        report_name: str | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Create a data drift report for embeddings.\n\n        Args:\n            reference_embeddings: Reference (baseline) embeddings\n            current_embeddings: Current embeddings to compare\n            reference_ids: IDs for reference embeddings\n            current_ids: IDs for current embeddings\n            report_name: Optional custom report name\n\n        Returns:\n            Path to the generated report\n        \"\"\"\n        logger.info(\"Creating embedding drift report\")\n\n        # Convert to DataFrames\n        ref_df = self._embeddings_to_dataframe(reference_embeddings, reference_ids)\n        curr_df = self._embeddings_to_dataframe(current_embeddings, current_ids)\n\n        # Create report\n        report = Report(\n            metrics=[\n                DataDriftPreset(),\n                DataQualityPreset(),\n            ]\n        )\n\n        report.run(reference_data=ref_df, current_data=curr_df)\n\n        # Save report\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        report_name = report_name or f\"embedding_drift_{timestamp}\"\n        report_path = self.reports_dir / f\"{report_name}.html\"\n\n        report.save_html(str(report_path))\n        logger.info(f\"Report saved to: {report_path}\")\n\n        # Save JSON summary\n        json_path = self.reports_dir / f\"{report_name}.json\"\n        report.save_json(str(json_path))\n\n        return str(report_path)\n\n    def create_recommendation_quality_report(\n        self,\n        recommendations_data: pd.DataFrame,\n        reference_data: pd.DataFrame | None = None,\n        report_name: str | None = None,\n    ) -&gt; str:\n        \"\"\"\n        Create a report for recommendation quality metrics.\n\n        Args:\n            recommendations_data: DataFrame with recommendation results\n                Expected columns: query_id, restaurant_id, similarity_score, rank\n            reference_data: Optional reference data for comparison\n            report_name: Optional custom report name\n\n        Returns:\n            Path to the generated report\n        \"\"\"\n        logger.info(\"Creating recommendation quality report\")\n\n        if reference_data is not None:\n            report = Report(\n                metrics=[\n                    DataDriftPreset(),\n                    DataQualityPreset(),\n                ]\n            )\n            report.run(reference_data=reference_data, current_data=recommendations_data)\n        else:\n            report = Report(\n                metrics=[\n                    DataQualityPreset(),\n                ]\n            )\n            report.run(reference_data=None, current_data=recommendations_data)\n\n        # Save report\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        report_name = report_name or f\"recommendation_quality_{timestamp}\"\n        report_path = self.reports_dir / f\"{report_name}.html\"\n\n        report.save_html(str(report_path))\n        logger.info(f\"Report saved to: {report_path}\")\n\n        return str(report_path)\n\n    def run_data_quality_tests(\n        self,\n        data: pd.DataFrame,\n        test_name: str | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Run data quality tests on the provided data.\n\n        Args:\n            data: DataFrame to test\n            test_name: Optional custom test name\n\n        Returns:\n            Dictionary with test results\n        \"\"\"\n        logger.info(\"Running data quality tests\")\n\n        test_suite = TestSuite(\n            tests=[\n                DataQualityTestPreset(),\n            ]\n        )\n\n        test_suite.run(reference_data=None, current_data=data)\n\n        # Save test results\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        test_name = test_name or f\"data_quality_{timestamp}\"\n        test_path = self.tests_dir / f\"{test_name}.html\"\n\n        test_suite.save_html(str(test_path))\n        logger.info(f\"Test results saved to: {test_path}\")\n\n        # Get test results as dict\n        results: dict[str, Any] = test_suite.as_dict()\n\n        # Save JSON\n        json_path = self.tests_dir / f\"{test_name}.json\"\n        with open(json_path, \"w\") as f:\n            json.dump(results, f, indent=2)\n\n        return results\n\n    def run_drift_tests(\n        self,\n        reference_data: pd.DataFrame,\n        current_data: pd.DataFrame,\n        test_name: str | None = None,\n    ) -&gt; dict[str, Any]:\n        \"\"\"\n        Run data drift tests comparing reference and current data.\n\n        Args:\n            reference_data: Reference (baseline) data\n            current_data: Current data to test\n            test_name: Optional custom test name\n\n        Returns:\n            Dictionary with test results\n        \"\"\"\n        logger.info(\"Running data drift tests\")\n\n        test_suite = TestSuite(\n            tests=[\n                DataDriftTestPreset(),\n            ]\n        )\n\n        test_suite.run(reference_data=reference_data, current_data=current_data)\n\n        # Save test results\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        test_name = test_name or f\"data_drift_{timestamp}\"\n        test_path = self.tests_dir / f\"{test_name}.html\"\n\n        test_suite.save_html(str(test_path))\n        logger.info(f\"Test results saved to: {test_path}\")\n\n        # Get test results as dict\n        results: dict[str, Any] = test_suite.as_dict()\n\n        # Save JSON\n        json_path = self.tests_dir / f\"{test_name}.json\"\n        with open(json_path, \"w\") as f:\n            json.dump(results, f, indent=2)\n\n        return results\n\n    def _embeddings_to_dataframe(\n        self,\n        embeddings: np.ndarray,\n        ids: list[str],\n    ) -&gt; pd.DataFrame:\n        \"\"\"\n        Convert embeddings array to DataFrame.\n\n        Args:\n            embeddings: Numpy array of embeddings\n            ids: List of IDs\n\n        Returns:\n            DataFrame with embeddings as columns\n        \"\"\"\n        # Create column names\n        n_dims = embeddings.shape[1]\n        columns = [f\"dim_{i}\" for i in range(n_dims)]\n\n        # Create DataFrame\n        df = pd.DataFrame(embeddings, columns=columns)\n        df.insert(0, \"id\", ids)\n\n        return df\n\n    def generate_monitoring_dashboard(\n        self,\n        embeddings: np.ndarray,\n        ids: list[str],\n        recommendations: pd.DataFrame,\n        dashboard_name: str | None = None,\n    ) -&gt; dict[str, str]:\n        \"\"\"\n        Generate a comprehensive monitoring dashboard.\n\n        Args:\n            embeddings: Current embeddings\n            ids: Embedding IDs\n            recommendations: Recent recommendations data\n            dashboard_name: Optional custom dashboard name\n\n        Returns:\n            Dictionary with paths to generated reports\n        \"\"\"\n        logger.info(\"Generating monitoring dashboard\")\n\n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        dashboard_name = dashboard_name or f\"dashboard_{timestamp}\"\n\n        # Convert embeddings to DataFrame\n        embeddings_df = self._embeddings_to_dataframe(embeddings, ids)\n\n        # Run data quality tests\n        self.run_data_quality_tests(\n            embeddings_df, test_name=f\"{dashboard_name}_embeddings_quality\"\n        )\n\n        # Create recommendation quality report\n        rec_report = self.create_recommendation_quality_report(\n            recommendations, report_name=f\"{dashboard_name}_recommendations\"\n        )\n\n        paths = {\n            \"embeddings_quality_test\": str(\n                self.tests_dir / f\"{dashboard_name}_embeddings_quality.html\"\n            ),\n            \"recommendations_report\": rec_report,\n        }\n\n        logger.info(f\"Dashboard generated with {len(paths)} reports\")\n        return paths\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.EvidentlyMonitor.__init__","title":"<code>__init__(reports_dir=Path('monitoring/reports'), tests_dir=Path('monitoring/tests'))</code>","text":"<p>Initialize Evidently monitor.</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def __init__(\n    self,\n    reports_dir: Path = Path(\"monitoring/reports\"),\n    tests_dir: Path = Path(\"monitoring/tests\"),\n):\n    \"\"\"Initialize Evidently monitor.\"\"\"\n    self.reports_dir = Path(reports_dir)\n    self.tests_dir = Path(tests_dir)\n\n    # Create directories\n    self.reports_dir.mkdir(parents=True, exist_ok=True)\n    self.tests_dir.mkdir(parents=True, exist_ok=True)\n\n    logger.info(\"Evidently monitor initialized\")\n    logger.info(f\"Reports directory: {self.reports_dir}\")\n    logger.info(f\"Tests directory: {self.tests_dir}\")\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.EvidentlyMonitor.create_embedding_drift_report","title":"<code>create_embedding_drift_report(reference_embeddings, current_embeddings, reference_ids, current_ids, report_name=None)</code>","text":"<p>Create a data drift report for embeddings.</p> <p>Parameters:</p> Name Type Description Default <code>reference_embeddings</code> <code>ndarray</code> <p>Reference (baseline) embeddings</p> required <code>current_embeddings</code> <code>ndarray</code> <p>Current embeddings to compare</p> required <code>reference_ids</code> <code>list[str]</code> <p>IDs for reference embeddings</p> required <code>current_ids</code> <code>list[str]</code> <p>IDs for current embeddings</p> required <code>report_name</code> <code>str | None</code> <p>Optional custom report name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the generated report</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def create_embedding_drift_report(\n    self,\n    reference_embeddings: np.ndarray,\n    current_embeddings: np.ndarray,\n    reference_ids: list[str],\n    current_ids: list[str],\n    report_name: str | None = None,\n) -&gt; str:\n    \"\"\"\n    Create a data drift report for embeddings.\n\n    Args:\n        reference_embeddings: Reference (baseline) embeddings\n        current_embeddings: Current embeddings to compare\n        reference_ids: IDs for reference embeddings\n        current_ids: IDs for current embeddings\n        report_name: Optional custom report name\n\n    Returns:\n        Path to the generated report\n    \"\"\"\n    logger.info(\"Creating embedding drift report\")\n\n    # Convert to DataFrames\n    ref_df = self._embeddings_to_dataframe(reference_embeddings, reference_ids)\n    curr_df = self._embeddings_to_dataframe(current_embeddings, current_ids)\n\n    # Create report\n    report = Report(\n        metrics=[\n            DataDriftPreset(),\n            DataQualityPreset(),\n        ]\n    )\n\n    report.run(reference_data=ref_df, current_data=curr_df)\n\n    # Save report\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    report_name = report_name or f\"embedding_drift_{timestamp}\"\n    report_path = self.reports_dir / f\"{report_name}.html\"\n\n    report.save_html(str(report_path))\n    logger.info(f\"Report saved to: {report_path}\")\n\n    # Save JSON summary\n    json_path = self.reports_dir / f\"{report_name}.json\"\n    report.save_json(str(json_path))\n\n    return str(report_path)\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.EvidentlyMonitor.create_recommendation_quality_report","title":"<code>create_recommendation_quality_report(recommendations_data, reference_data=None, report_name=None)</code>","text":"<p>Create a report for recommendation quality metrics.</p> <p>Parameters:</p> Name Type Description Default <code>recommendations_data</code> <code>DataFrame</code> <p>DataFrame with recommendation results Expected columns: query_id, restaurant_id, similarity_score, rank</p> required <code>reference_data</code> <code>DataFrame | None</code> <p>Optional reference data for comparison</p> <code>None</code> <code>report_name</code> <code>str | None</code> <p>Optional custom report name</p> <code>None</code> <p>Returns:</p> Type Description <code>str</code> <p>Path to the generated report</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def create_recommendation_quality_report(\n    self,\n    recommendations_data: pd.DataFrame,\n    reference_data: pd.DataFrame | None = None,\n    report_name: str | None = None,\n) -&gt; str:\n    \"\"\"\n    Create a report for recommendation quality metrics.\n\n    Args:\n        recommendations_data: DataFrame with recommendation results\n            Expected columns: query_id, restaurant_id, similarity_score, rank\n        reference_data: Optional reference data for comparison\n        report_name: Optional custom report name\n\n    Returns:\n        Path to the generated report\n    \"\"\"\n    logger.info(\"Creating recommendation quality report\")\n\n    if reference_data is not None:\n        report = Report(\n            metrics=[\n                DataDriftPreset(),\n                DataQualityPreset(),\n            ]\n        )\n        report.run(reference_data=reference_data, current_data=recommendations_data)\n    else:\n        report = Report(\n            metrics=[\n                DataQualityPreset(),\n            ]\n        )\n        report.run(reference_data=None, current_data=recommendations_data)\n\n    # Save report\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    report_name = report_name or f\"recommendation_quality_{timestamp}\"\n    report_path = self.reports_dir / f\"{report_name}.html\"\n\n    report.save_html(str(report_path))\n    logger.info(f\"Report saved to: {report_path}\")\n\n    return str(report_path)\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.EvidentlyMonitor.generate_monitoring_dashboard","title":"<code>generate_monitoring_dashboard(embeddings, ids, recommendations, dashboard_name=None)</code>","text":"<p>Generate a comprehensive monitoring dashboard.</p> <p>Parameters:</p> Name Type Description Default <code>embeddings</code> <code>ndarray</code> <p>Current embeddings</p> required <code>ids</code> <code>list[str]</code> <p>Embedding IDs</p> required <code>recommendations</code> <code>DataFrame</code> <p>Recent recommendations data</p> required <code>dashboard_name</code> <code>str | None</code> <p>Optional custom dashboard name</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary with paths to generated reports</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def generate_monitoring_dashboard(\n    self,\n    embeddings: np.ndarray,\n    ids: list[str],\n    recommendations: pd.DataFrame,\n    dashboard_name: str | None = None,\n) -&gt; dict[str, str]:\n    \"\"\"\n    Generate a comprehensive monitoring dashboard.\n\n    Args:\n        embeddings: Current embeddings\n        ids: Embedding IDs\n        recommendations: Recent recommendations data\n        dashboard_name: Optional custom dashboard name\n\n    Returns:\n        Dictionary with paths to generated reports\n    \"\"\"\n    logger.info(\"Generating monitoring dashboard\")\n\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    dashboard_name = dashboard_name or f\"dashboard_{timestamp}\"\n\n    # Convert embeddings to DataFrame\n    embeddings_df = self._embeddings_to_dataframe(embeddings, ids)\n\n    # Run data quality tests\n    self.run_data_quality_tests(\n        embeddings_df, test_name=f\"{dashboard_name}_embeddings_quality\"\n    )\n\n    # Create recommendation quality report\n    rec_report = self.create_recommendation_quality_report(\n        recommendations, report_name=f\"{dashboard_name}_recommendations\"\n    )\n\n    paths = {\n        \"embeddings_quality_test\": str(\n            self.tests_dir / f\"{dashboard_name}_embeddings_quality.html\"\n        ),\n        \"recommendations_report\": rec_report,\n    }\n\n    logger.info(f\"Dashboard generated with {len(paths)} reports\")\n    return paths\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.EvidentlyMonitor.run_data_quality_tests","title":"<code>run_data_quality_tests(data, test_name=None)</code>","text":"<p>Run data quality tests on the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DataFrame</code> <p>DataFrame to test</p> required <code>test_name</code> <code>str | None</code> <p>Optional custom test name</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with test results</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def run_data_quality_tests(\n    self,\n    data: pd.DataFrame,\n    test_name: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Run data quality tests on the provided data.\n\n    Args:\n        data: DataFrame to test\n        test_name: Optional custom test name\n\n    Returns:\n        Dictionary with test results\n    \"\"\"\n    logger.info(\"Running data quality tests\")\n\n    test_suite = TestSuite(\n        tests=[\n            DataQualityTestPreset(),\n        ]\n    )\n\n    test_suite.run(reference_data=None, current_data=data)\n\n    # Save test results\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    test_name = test_name or f\"data_quality_{timestamp}\"\n    test_path = self.tests_dir / f\"{test_name}.html\"\n\n    test_suite.save_html(str(test_path))\n    logger.info(f\"Test results saved to: {test_path}\")\n\n    # Get test results as dict\n    results: dict[str, Any] = test_suite.as_dict()\n\n    # Save JSON\n    json_path = self.tests_dir / f\"{test_name}.json\"\n    with open(json_path, \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    return results\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.EvidentlyMonitor.run_drift_tests","title":"<code>run_drift_tests(reference_data, current_data, test_name=None)</code>","text":"<p>Run data drift tests comparing reference and current data.</p> <p>Parameters:</p> Name Type Description Default <code>reference_data</code> <code>DataFrame</code> <p>Reference (baseline) data</p> required <code>current_data</code> <code>DataFrame</code> <p>Current data to test</p> required <code>test_name</code> <code>str | None</code> <p>Optional custom test name</p> <code>None</code> <p>Returns:</p> Type Description <code>dict[str, Any]</code> <p>Dictionary with test results</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def run_drift_tests(\n    self,\n    reference_data: pd.DataFrame,\n    current_data: pd.DataFrame,\n    test_name: str | None = None,\n) -&gt; dict[str, Any]:\n    \"\"\"\n    Run data drift tests comparing reference and current data.\n\n    Args:\n        reference_data: Reference (baseline) data\n        current_data: Current data to test\n        test_name: Optional custom test name\n\n    Returns:\n        Dictionary with test results\n    \"\"\"\n    logger.info(\"Running data drift tests\")\n\n    test_suite = TestSuite(\n        tests=[\n            DataDriftTestPreset(),\n        ]\n    )\n\n    test_suite.run(reference_data=reference_data, current_data=current_data)\n\n    # Save test results\n    timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n    test_name = test_name or f\"data_drift_{timestamp}\"\n    test_path = self.tests_dir / f\"{test_name}.html\"\n\n    test_suite.save_html(str(test_path))\n    logger.info(f\"Test results saved to: {test_path}\")\n\n    # Get test results as dict\n    results: dict[str, Any] = test_suite.as_dict()\n\n    # Save JSON\n    json_path = self.tests_dir / f\"{test_name}.json\"\n    with open(json_path, \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    return results\n</code></pre>"},{"location":"reference/vibecheck/monitoring/evidently_monitor/#vibecheck.monitoring.evidently_monitor.create_sample_recommendations_data","title":"<code>create_sample_recommendations_data(query_ids, restaurant_ids, similarity_scores)</code>","text":"<p>Helper function to create sample recommendations DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>query_ids</code> <code>list[str]</code> <p>List of query IDs</p> required <code>restaurant_ids</code> <code>list[str]</code> <p>List of recommended restaurant IDs</p> required <code>similarity_scores</code> <code>list[float]</code> <p>List of similarity scores</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame with recommendations data</p> Source code in <code>src/vibecheck/monitoring/evidently_monitor.py</code> <pre><code>def create_sample_recommendations_data(\n    query_ids: list[str],\n    restaurant_ids: list[str],\n    similarity_scores: list[float],\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Helper function to create sample recommendations DataFrame.\n\n    Args:\n        query_ids: List of query IDs\n        restaurant_ids: List of recommended restaurant IDs\n        similarity_scores: List of similarity scores\n\n    Returns:\n        DataFrame with recommendations data\n    \"\"\"\n    return pd.DataFrame(\n        {\n            \"query_id\": query_ids,\n            \"restaurant_id\": restaurant_ids,\n            \"similarity_score\": similarity_scores,\n            \"timestamp\": datetime.now(),\n        }\n    )\n</code></pre>"},{"location":"user-guide/api/","title":"Internal API Examples","text":""},{"location":"user-guide/api/#for-developers-and-researchers","title":"For Developers and Researchers","text":"<p>These examples show how to use the VibeCheck internal API for experiments and analysis.</p>"},{"location":"user-guide/api/#basic-usage","title":"Basic Usage","text":"<pre><code>from vibecheck import VibeCheckRecommender\nfrom PIL import Image\n\n# Initialize recommender\nrecommender = VibeCheckRecommender()\n\n# Search by text\nresults = recommender.search_by_text(\"cozy cafe with plants\", top_k=5)\nfor resto in results:\n    print(f\"{resto['name']}: {resto['similarity']:.2%} match\")\n\n# Search by image\nimg = Image.open(\"ideal_restaurant.jpg\")\nresults = recommender.search_by_image(img, top_k=5)\nfor resto in results:\n    print(resto['name'])\n\n# Search with both\nresults = recommender.search_multimodal(\n    text=\"cozy atmosphere\",\n    image=img,\n    top_k=5\n)\n</code></pre>"},{"location":"user-guide/api/#running-experiments","title":"Running Experiments","text":"<pre><code># Evaluate text search quality\ntest_queries = [\n    \"cozy cafe with plants\",\n    \"modern minimalist restaurant\",\n    \"rustic farmhouse dining\"\n]\n\nfor query in test_queries:\n    results = recommender.search_by_text(query, top_k=10)\n    print(f\"\\nQuery: {query}\")\n    for resto in results[:3]:\n        print(f\"  {resto['name']} ({resto['similarity']:.2f})\")\n</code></pre>"},{"location":"user-guide/api/#reproducibility","title":"Reproducibility","text":"<p>All experiments can be reproduced using the same model weights and FAISS index: <pre><code># Exact reproduction\nrecommender = VibeCheckRecommender(\n    db_path=\"restaurants.db\",\n    faiss_index_path=\"vibecheck_index.faiss\",\n    meta_ids_path=\"meta_ids.npy\"\n)\n\n# Results will be identical\nresults = recommender.search_by_text(\"cozy cafe\", top_k=5)\n</code></pre></p>"},{"location":"user-guide/getting-started/","title":"Getting Started","text":""},{"location":"user-guide/getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.10 or higher</li> <li>Poetry (Python package manager)</li> <li>Git</li> </ul>"},{"location":"user-guide/getting-started/#installation","title":"Installation","text":""},{"location":"user-guide/getting-started/#1-clone-the-repository","title":"1. Clone the Repository","text":"<pre><code>git clone https://github.com/kristinmlloyd/VibeCheck.git\ncd VibeCheck\n</code></pre>"},{"location":"user-guide/getting-started/#2-install-dependencies","title":"2. Install Dependencies","text":"<pre><code># Install Poetry if you haven't already\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Install project dependencies\npoetry install\n</code></pre>"},{"location":"user-guide/getting-started/#3-set-up-environment-variables","title":"3. Set Up Environment Variables","text":"<p>Create a <code>.env</code> file in the project root: <pre><code>SERPAPI_KEY=your_serpapi_key_here\n</code></pre></p>"},{"location":"user-guide/getting-started/#4-run-tests","title":"4. Run Tests","text":"<p>Verify your installation: <pre><code>poetry run pytest tests/\n</code></pre></p>"},{"location":"user-guide/getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Read the Quick Start Guide to start using VibeCheck</li> <li>Explore the API Reference for detailed code documentation</li> <li>Check out Contributing Guidelines to contribute to the project</li> </ul>"},{"location":"user-guide/installation/","title":"Installation Guide","text":""},{"location":"user-guide/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Operating System: macOS, Linux, or Windows</li> <li>Python: Version 3.10 or higher</li> <li>Memory: At least 4GB RAM recommended</li> <li>Storage: At least 1GB free space for images and data</li> </ul>"},{"location":"user-guide/installation/#step-by-step-installation","title":"Step-by-Step Installation","text":""},{"location":"user-guide/installation/#1-install-python","title":"1. Install Python","text":"<p>If you don't have Python 3.10+:</p> <p>macOS (using Homebrew): <pre><code>brew install python@3.11\n</code></pre></p> <p>Ubuntu/Debian: <pre><code>sudo apt update\nsudo apt install python3.11\n</code></pre></p> <p>Windows: Download from python.org</p>"},{"location":"user-guide/installation/#2-install-poetry","title":"2. Install Poetry","text":"<pre><code>curl -sSL https://install.python-poetry.org | python3 -\n</code></pre> <p>Add Poetry to your PATH (follow the instructions after installation).</p>"},{"location":"user-guide/installation/#3-clone-and-install-vibecheck","title":"3. Clone and Install VibeCheck","text":"<pre><code># Clone repository\ngit clone https://github.com/kristinmlloyd/VibeCheck.git\ncd VibeCheck\n\n# Install dependencies\npoetry install\n\n# Activate virtual environment\npoetry shell\n</code></pre>"},{"location":"user-guide/installation/#4-verify-installation","title":"4. Verify Installation","text":"<pre><code># Run tests\npoetry run pytest\n\n# Check linting\npoetry run ruff check src/\n</code></pre>"},{"location":"user-guide/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"user-guide/installation/#poetry-not-found","title":"Poetry not found","text":"<p>Make sure Poetry is in your PATH: <pre><code>export PATH=\"$HOME/.local/bin:$PATH\"\n</code></pre></p>"},{"location":"user-guide/installation/#python-version-mismatch","title":"Python version mismatch","text":"<p>Ensure you're using Python 3.10+: <pre><code>python --version\n</code></pre></p>"},{"location":"user-guide/installation/#dependency-conflicts","title":"Dependency conflicts","text":"<p>Try clearing the cache: <pre><code>poetry cache clear pypi --all\npoetry install\n</code></pre></p>"},{"location":"user-guide/installation/#optional-development-setup","title":"Optional: Development Setup","text":"<p>For contributors: <pre><code># Install pre-commit hooks\npoetry run pre-commit install\n\n# Install all development dependencies\npoetry install --with dev\n</code></pre></p>"},{"location":"user-guide/quick-start/","title":"Quick Start Guide","text":"<p>Get up and running with VibeCheck in minutes!</p>"},{"location":"user-guide/quick-start/#basic-usage","title":"Basic Usage","text":""},{"location":"user-guide/quick-start/#1-activate-environment","title":"1. Activate Environment","text":"<pre><code>cd VibeCheck\npoetry shell\n</code></pre>"},{"location":"user-guide/quick-start/#2-collect-restaurant-data","title":"2. Collect Restaurant Data","text":"<pre><code>from vibecheck.data_collection import RestaurantCollector\n\n# Initialize collector\ncollector = RestaurantCollector(api_key=\"your_serpapi_key\")\n\n# Collect images for restaurants\ncollector.collect_images(restaurant_names=[\"Restaurant Name\"])\n</code></pre>"},{"location":"user-guide/quick-start/#3-process-images","title":"3. Process Images","text":"<pre><code>from vibecheck.preprocessing import ImagePreprocessor\n\n# Initialize preprocessor\npreprocessor = ImagePreprocessor()\n\n# Process collected images\npreprocessor.process_directory(\"restaurant_images/\")\n</code></pre>"},{"location":"user-guide/quick-start/#4-find-similar-restaurants","title":"4. Find Similar Restaurants","text":"<pre><code>from vibecheck.similarity import SimilarityMatcher\n\n# Initialize matcher\nmatcher = SimilarityMatcher()\n\n# Find similar restaurants\nsimilar = matcher.find_similar(\"Restaurant Name\", top_k=5)\nprint(similar)\n</code></pre>"},{"location":"user-guide/quick-start/#running-the-application","title":"Running the Application","text":""},{"location":"user-guide/quick-start/#web-interface","title":"Web Interface","text":"<pre><code># Start the web application\npoetry run streamlit run app.py\n</code></pre> <p>Visit <code>http://localhost:8501</code> in your browser.</p>"},{"location":"user-guide/quick-start/#example-workflow","title":"Example Workflow","text":"<p>Here's a complete example: <pre><code>from vibecheck import VibeCheck\n\n# Initialize VibeCheck\nvc = VibeCheck(api_key=\"your_key\")\n\n# Add a restaurant\nvc.add_restaurant(\"Founding Farmers DC\")\n\n# Get recommendations based on aesthetics\nrecommendations = vc.recommend_similar(\n    restaurant_name=\"Founding Farmers DC\",\n    top_k=5\n)\n\n# Display results\nfor resto in recommendations:\n    print(f\"{resto['name']}: {resto['similarity']:.2f}\")\n</code></pre></p>"},{"location":"user-guide/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Explore the API Reference for detailed documentation</li> <li>Check out example notebooks in <code>/notebooks</code></li> <li>Read the Contributing Guide to contribute</li> </ul>"}]}